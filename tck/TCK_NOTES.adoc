= Named Graphs =

The TCK relies on a number of included named graphs.


== Metadata File ==

Each named graph is declared using a JSON file that references various Cypher script files for importing the graph as well as includes some additional statistical information.

This JSON file is called the metadata file.

=== Statistics Generation ===

The following sections contain queries for the original Neo4j implementation of Cypher that have been used to generate the statistical information for some of the named graphs used in the TCK.

These queries use the APOC procedure library for the generation of JSON results.

=== Advices ===

Some of the statistical information is annotated with additional advices (strings) that describes valid inferences that may be drawn from it in the context of how the given named graph is used in the TCK.

Advices must never influence the semantics of query execution.


== Property Statistics ==

Property statistics generally describe how many of a certain kind of entities have a given property as well as how many distinct (different) property values are assigned to them.

Property statistics entries use the empty string as a wildcard token (i.e. for describing any property key, or any node with or without labels).

The metadata file currently may contain three types of advice for property statistics entries.

A property statistics entry annotated with the advice `unique` indicates that each possible property value is at most assigned to one entity in the entry's context.

This is already visible from the included statistics.

However the advice additionally indicates that no included scenario will ever violate this constraint (by performing updates to the graph).

A property statistics entry annotated with the advice `exists` indicates that each entity in the entry's context has the property.

This is already visible from the included statistics.

However the advice additionally indicates that no included scenario will ever violate this constraint (by performing updates to the graph).

A property statistics entry annotated with the advice `index` indicates that some scenarios include queries that try to match on entities in the entry's context via a property comparison (e.g. `MATCH (n:Label {prop: {value}}) RETURN n`).

An implementation of the TCK may decide to interpret such an advice by creating a corresponding index.

=== For Nodes ===

[source,cypher]
.Generate JSON for node-label-property statistics
----
match (n)
unwind ([''] + keys(n)) as key
with n, key, case key when '' then '' else n[key] end as value
unwind ([''] + labels(n)) as label
with label, key, count(value) as count, count(distinct value) as distinct
order by label, key
with { label: label, key: key, count: count, distinct: distinct } as map
with collect(map) as maps
call apoc.convert.toJson(maps) yield value
return value;
----

=== For Relationships ===

[source,cypher]
.Generate JSON for rel-type-property statistics
----
match ()-[r]->()
unwind ([''] + keys(r)) as key
with r, key, case key when '' then '' else r[key] end as value
unwind ['', type(r)] as type
with type, key, count(value) as count, count(distinct value) as distinct
order by type, key
with { type: type, key: key, count: count, distinct: distinct } as map
with collect(map) as maps
call apoc.convert.toJson(maps) yield value
return value;
----


== Sublabel statistics

Sublabel statistics describe for each labels which other labels a node may have.

These are called the label's sublabels.

Sublabel statistics are useful to detect label implications (i.e. each Actor is always a Person).

If a sublabel implication is valid for the given named graph, the corresponding sublabel statistics entry is annotated with the advice `implied`.

[source,cypher]
.Generate JSON for sublabels
----
match (n)
unwind labels(n) as label
with label, count(n) as label_count
match (n)
with *, labels(n) as other_labels
where label in other_labels
unwind other_labels as other_label
with * where other_label <> label
with label, label_count, other_label, count(other_label) as other_label_count
order by label, other_label
with label, label_count, { label: other_label, count: other_label_count } as value
with label, label_count, collect(value) as values
with { label: label, count: label_count, sublabels: values } as map
with collect(map) as maps
call apoc.convert.toJson(maps) yield value
return value;
----
