= CIP2016-06-22 - Nested, updating, and chained subqueries
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Petra Selmer <petra.selmer@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP proposes the incorporation of nested, updating, and chained subqueries into Cypher.
--

toc::[]


== Motivation

Subqueries - i.e. queries within queries - are a powerful and expressive feature allowing for:

  * Increased query expressivity
  * Better query construction and readability
  * Easier composition of simple query pipelines
  * Post-processing results from multiple queries as a single unit
  * Performing a sequence of multiple write commands for each record

== Background

This CIP may be viewed in light of CIPs for query combinators and set operations, `EXISTS`, scalar subqueries, and list subqueries.

== Proposal

Subqueries are self-contained Cypher queries that are usually run within the scope of an outer, containing Cypher query.

This proposal suggests the introduction of new subquery constructs to Cypher.

* Read-only nested subqueries
** Read-only nested regular subqueries of the form `MATCH { <reading-query> }`
** Read-only nested optional subqueries of the form `OPTIONAL MATCH { <reading-query> }`
** Read-only nested mandatory subqueries of the form `MANDATORY MATCH { <reading-query> }`
* Read/Write updating subqueries
** Read/Write simple updating subqueries of the form `DO { <updating-query> }` (inner query not ending with `RETURN`)
** Read/Write conditionally-updating subqueries of the form `DO [WHEN <predicate> THEN { <updating-query> }]+ [ELSE { <updating-query> }] END` (inner queries not ending with `RETURN`)
* Chained subqueries
** Chained data-dependent subqueries by extending the `WITH` projection clause that have the form `<query> <with-clause> <query>`. Additionally, this CIP proposes new shorthand syntax for starting a query with `WITH` to compose a query with external inputs.
** Chained data-independent subqueries by introducing the new `THEN` clause for discarding all variables in scope as well as the cardinality of all input records. Additionally, this CIP proposes new shorthand syntax for discarding all variables in scope without discarding the cardinality of input records using `WITH|RETURN|YIELD NOTHING`.

We additionally propose removing the `FOREACH` clause from the current language (it is rendered obsolete by the introduction of `DO`).

Subquery constructs are always introduced with a keyword(s) in conjunction with an inner query in curly braces.

Subqueries may be correlated - i.e. the inner query may use variables from the outer query - or uncorrelated.

Subqueries can be contained within other subqueries at an arbitrary (but finite) depth.

Read/Write subqueries cannot be contained within other read-only subqueries.


=== Read-only nested subqueries

Conceptually, a nested subquery is evaluated for each incoming input record and may produce an arbitrary number of output records.

==== Read-only nested regular subqueries

We propose the addition of read-only nested regular subqueries as a new form of read-only Cypher query.

A nested read-only simple subquery is denoted using the following syntax: `MATCH { <inner-query> }`.

The inner query can be any complete read-only Cypher query.

==== Read-only nested optional subqueries

We propose extending the `OPTIONAL MATCH` clause to express read-only nested optional subqueries.

A read-only nested optional subquery is denoted by the following syntax: `OPTIONAL MATCH { <inner-query> }`.

==== Read-only nested mandatory subqueries

We propose extending the `MANDATORY MATCH` clause to express read-only nested mandatory subqueries.

A read-only nested mandatory subquery is denoted by the following syntax: `MANDATORY MATCH { <inner-query> }`.

==== Semantics

The nested subquery will be provided with all variables visible in the outer query as subquery input.

All records returned by the final `RETURN` clause of the subquery will be augmented with the variable bindings of the initial input record from the outer query to form the output records of the subquery.
No other variable bindings will be added to the output records.
If an incoming variable is either discarded or shadows within the subquery, an error will be raised if the subquery returns that variable to the outer query.

Finally, the result records of the different forms of nested subqueries are formed as follows:

* The result records of a read-only regular subquery are just the output records.
* The result records of a read-only optional subquery are all the output records (if there is at least one output record), or a single record with the same fields as the output records where all newly introduced variable bindings are set to `NULL`.
* The result records of a read-only mandatory subquery are just the output records. However, if the set of output records is empty, an error is raised in the same way as regular `MANDATORY MATCH`.

Nested subqueries interact with write clauses in the same way as `MATCH` does.


=== Read/Write updating subqueries

Updating subqueries never change the cardinality; i.e. the inner update query is run for each incoming input record.

==== Read/Write simple updating subqueries

We propose the addition of a new `DO` clause for expressing read/write simple updating subqueries that _do not return any data_ from the inner query.

A read/write simple updating subquery is denoted by the following syntax: `DO { <inner-update-query> }`.

Any updating Cypher query from which the trailing final `RETURN` clause has been omitted may be used as an inner update query.

A query may end with a `DO` subquery in the same way that a query can currently end with any update clause.

==== Read/Write conditionally-updating subqueries

We propose the addition of a new conditional `DO` clause for expressing read/write conditionally-updating subqueries that _do not return any data_ from the inner query.

A read/write conditionally-updating subquery is denoted by the following syntax:

```
DO
  [WHEN <predicate> THEN <inner-update-query>]+
  [ELSE <inner-update-query>]
END
```

Evaluation proceeds as follows:

* Semantically, the `WHEN` predicates are tested in the order given, and the inner updating query is executed for only the first predicate that evaluates to `true`.
* If no given `WHEN` predicates evaluates to `true` and an `ELSE` branch is provided, the inner updating query of the `ELSE` branch is executed.
* If no given `WHEN` predicates evaluates to `true` and no `ELSE` branch is provided, no updates will be executed.

A query may end with a conditional `DO` subquery in the same way that a query can currently end with any update clause.


=== Chained subqueries

==== Chained data-dependent subqueries

We propose extending the `WITH` projection clause to sequentially compose arbitrary queries to form a chained data-dependent subquery without resorting to nesting and indentation (e.g. as a short-hand syntax for post-UNION processing).

Chained data-dependent subqueries have the following general form `<Q1> WITH ... <Q2>`.

Both `<Q1`> and `<Q2>` are arbitrary, complete Cypher queries.

Conceptually, the query `<Q2>` is evaluated for each incoming input record from the query `<Q1>` and may produce an arbitrary number of result records.
In other words, the query `<Q2>` will be provided with all variables returned by the query `<Q1>` as input variable bindings.

Furthermore, this CIP proposes allowing a leading `WITH` to project variables from expressions that refer to unbound variables from the preceding scope (or query).
This set of referenced, unbound variables of such a leading `WITH` is understood to implicitly declare the input variables required for the query to execute.

Note:: This mechanism allows composing a Cypher query with inputs that have been constructed programmatically.

==== Chained data-independent subqueries

We propose introducing the `THEN` projection clause to sequentially compose two arbitrary subqueries to form a chained data-independent subquery without resorting to nesting and indentation.

Chained data-independent subqueries have the following general form `<Q1> THEN <Q2>`.

Both `<Q1`> and `<Q2>` are arbitrary, complete Cypher queries.
No variables and no input records are passed from `<Q1>` to `<Q2>`.
Instead `<Q2>` is executed in a standalone fashion after the execution of `<Q1>` has finished.

Furthermore, this CIP proposes allowing queries to start with a leading `THEN` for discarding all variables in scope as well as the cardinality of all input records provided by the surrounding execution environment.

Note:: This mechanism allows guaranteed execution of `<Q2>` irrespective of the number of records produced by `<Q1>`.

Note:: In general, `<Q1>` is expected to be an updating query and it is recommended that implementations generate a warning if this is not the case (to inform the user that `<Q1>` is essentially superfluous).

==== Precedence of subquery chaining

This CIP proposes to distinguish between full (top-level) queries and argument queries.

A full top-level query is any Cypher query.
In particular, a full top-level query may be formed by composing argument queries using subquery chaining or other query combinators (like `UNION`).

An argument query is a sequence of clauses that ends in either an updating clause or `RETURN`.
An argument query may not contain subquery chaining or another query combinator.

These rules establish left-associative precedence of subquery chaining and other query combinators over argument queries.

In other words, `<Q1> UNION <Q2> WITH <Q3>` is always interpreted as  `(<Q1> UNION <Q2>) WITH <Q3>` but never as `<Q1> UNION (<Q2> WITH <Q3>)` (The same rule applies to `THEN`).

Note:: Subquery chaining and other query combinators may still be used from inside an argument query via inner nested subqueries.

==== Discarding variables in scope

Finally, this CIP proposes new shorthand syntax for discarding all variables in scope without discarding the cardinality of input records using `WITH|RETURN|YIELD NOTHING`.

=== Examples

==== Read-only nested regular subqueries

Post-UNION processing:
[source, cypher]
----
MATCH {
  // authored tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:AUTHORED]-(tweet:Tweet)
  RETURN tweet, tweet.time AS time, user.country AS country
  UNION
  // favorited tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:HAS_FAVOURITE]-(favorite:Favorite)-[:TARGETS]->(tweet:Tweet)
  RETURN tweet, favourite.time AS time, user.country AS country
}
WHERE country = 'se'
RETURN DISTINCT tweet
ORDER BY time DESC
LIMIT 10
----

Uncorrelated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})-[:IS_IN]->(country:Country)
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Filtered and correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm)-[:IS_IN]->(country:Country)
WHERE country.name IN $countryNames
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b AS brand, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b AS brand, p.code AS code
}
WHERE f.type = 'organic'
  AND b.certified
RETURN f, brand.name AS name, code
----

Doubly-nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (c:Customer)-[:BUYS_FOOD_AT]->(f)
  MATCH {
     MATCH (c)-[:RETWEETS]->(t:Tweet)<-[:TWEETED_BY]-(f)
     RETURN c, count(*) AS count
     UNION
     MATCH (c)-[:LIKES]->(p:Posting)<-[:POSTED_BY]-(f)
     RETURN c, count(*) AS count
  }
  RETURN c, 'customer' AS type, sum(count) AS endorsement
  UNION
  MATCH (s:Shop)-[:BUYS_FOOD_AT]->(f)
  MATCH (s)-[:PLACES]->(a:Advertisement)-[:ABOUT]->(f)
  RETURN s, 'shop' AS type, count(a) * 100 AS endorsement
}
RETURN f.name AS name, type, sum(endorsement) AS endorsement
----

===== Read-only nested optional and mandatory subqueries

This proposal also provides nested subquery forms of `OPTIONAL MATCH` and `MANDATORY MATCH`:

[source, cypher]
----
MANDATORY MATCH (p:Person {name: 'Petra'})
MANDATORY MATCH (conf:Conference {name: $conf})
MANDATORY MATCH {
    WITH * WHERE conf.impact > 5
    MATCH (p)-[:ATTENDS]->(conf)
    RETURN conf
    UNION
    MATCH (p)-[:LIVES_IN]->(:City)<-[:IN]-(conf)
    RETURN conf
}
OPTIONAL MATCH {
    MATCH (p)-[:KNOWS]->(a:Attendee)-[:PUBLISHED_AT]->(conf)
    RETURN a.name AS name
    UNION
    MATCH (p)-[:KNOWS]->(a:Attendee)-[:PRESENTED_AT]->(conf)
    RETURN a.name AS name
}
RETURN name
----


==== Read/Write simple updating and conditionally-updating subqueries

We illustrate these by means of an 'old' version of the query, in which `FOREACH` is used, followed by the 'new' version, using `DO`.

Using a single subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH(x IN range(1, 10) |
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
)
----

Using a single subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO {
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
}
----

Note how `FOREACH` is addressing two semantic concerns simultaneously; namely looping, and performing updates without affecting the cardinality of the outer query.
In the new version of the query shown above, these orthogonal concerns have been separated.
Looping is already handled by `UNWIND`, while `DO` suppresses the increased cardinality from the inner query.

`DO` also hides all new variable bindings introduced by the inner query from the outer query.
If `DO` is omitted from the new version of the query shown above, the variable `c` would become visible to the remainder of the query.

Doubly-nested subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH (x IN range(1, 10) |
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  FOREACH (y IN range(1, 10) |
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  )
)
----

Doubly-nested subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x AS x
DO {
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  UNWIND range(1, 10) AS y
  DO {
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  }
}
----

Conditional `DO`
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO WHEN x % 2 = 1 THEN {
      MERGE (c:Odd:Child {id: x})
      MERGE (r)-[:PARENT]->(c)
  }
  ELSE {
      MERGE (c:Even:Child {id: x})
      MERGE (r)-[:PARENT]->(c)
  }
END
----

==== Chained subqueries

Combining nested and chained subqueries
[source, cypher]
----
MATCH (x)-[:IN]->(:Category {name: "A"})
WITH x LIMIT 5
MATCH (x)-[:FROM]-(c :City)
RETURN x, c
UNION
MATCH (x)-[:IN]->(:Category {name: "A"})
WITH x LIMIT 10
MATCH (x)-[:FROM]-(c :City)
// This finished the right arm of the UNION
RETURN x, c
// This applies to the whole UNION
WITH x.name AS name ORDER BY x.age
RETURN x LIMIT 10
----

=== Interaction with existing features

Apart from the suggested deprecation of the `FOREACH` clause, nested read-only, write-only and read-write subqueries do not interact directly with any existing features.

== Alternatives

Alternative syntax has been considered during the production of this document:

  * Using round braces; i.e. `MATCH (...)`
  * Using alternative keywords:

    ** `SUBQUERY`
    ** `QUERY`

== What others do

=== SQL

The following types of subqueries are supported in SQL:

Scalar:
[source, cypher]
----
SELECT orderID
FROM Orders
WHERE orderID =
  (SELECT max(orderID) FROM Orders)
----

Multi-valued:
[source, cypher]
----
SELECT customerID
FROM Customers
WHERE customerID IN
  (SELECT customerID FROM Orders)
----

Correlated:
[source, cypher]
----
SELECT orderID, customerID
FROM Orders AS O1
WHERE orderID =
  (SELECT max(O2.orderID) FROM Orders AS O2
   WHERE O2.customerID = O1.customerID)
----

Table-valued/table expression:
[source, cypher]
----
SELECT orderYear
FROM
  (SELECT YEAR(orderDate) AS orderYear
  FROM Orders) AS D
----

Scalar and list subqueries are addressed in the Scalar Subqueries and List Subqueries CIP.

=== SPARQL

https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#subqueries[SPARQL] supports uncorrelated subqueries in the standard, exemplified by:

[source, cypher]
----
SELECT ?y ?minName
WHERE {
  :alice :knows ?y .
 {
    SELECT ?y (MIN(?name) AS ?minName)
    WHERE {
      ?y :name ?name .
    } GROUP BY ?y
  }
}
----

Owing to the bottom-up nature of SPARQL query evaluation, the supported forms of subqueries are evaluated logically first, and the results are projected up to the outer query.
Variables projected out of the subquery will be visible, or in scope, to the outer query.


== Benefits to this proposal

* Increasing the expressivity of the language.
* Allowing unified post-processing on results from multiple (sub)queries; this is exemplified by the https://github.com/neo4j/neo4j/issues/2725[request for post-UNION processing].
* Facilitating query readability, construction and maintainability.
* Providing a feature familiar to users of SQL.

== Caveats to this proposal

At the current time, we are not aware of any caveats.
