= CIP2017-02-06 Path Patterns
:encoding: UTF-8
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Tobias Lindaaker <tobias.lindaaker@neotechnology.com>

toc::[]

== Path Patterns

Above and beyond the types of patterns that can be expressed in Cypher using the normal path syntax, Cypher also supports what amounts to regular expressions over paths.
Queries of this type are typically referred to as Regular Path Queries (RPQs).
In Cypher Regular Path Queries can be expressed through the use of _Path Patterns_.
The _Path Patterns_ supported by Cypher are capable of supporting more than just regular expressions though.

A Path Pattern is defined as:

‚Ä¢ A simple relationship type +
  `()-[:X]-()` denotes a Path Pattern matching relationships of type `X`.
‚Ä¢ A predicate on the labels of a node +
  `()-[(:Z)]-()` denotes a Path Pattern matching nodes with label `Z`.
‚Ä¢ A sequence of Path Patterns +
  `()-[ùú∂ ùõΩ]-()` denotes a Path Pattern matching first the pattern defined by `ùú∂`, then the pattern defined by `ùõΩ` (in order left to right).
‚Ä¢ An alternative between Path Patterns +
  `()-[ùú∂ | ùõΩ]-()` denotes a Path Pattern matching either the pattern defined by `ùú∂` or the pattern defined by `ùõΩ`.
‚Ä¢ A repetition of a Path Pattern +
  `()-[ùú∂*]-()` denotes a Path Pattern matching the pattern defined by `ùú∂` zero or more times. +
  `()-[ùú∂+]-()` denotes a Path Pattern matching the pattern defined by `ùú∂` one or more times. +
  `()-[ùú∂*_x_..]-()` denotes a Path Pattern matching the pattern defined by `ùú∂` `_x_` or more times. +
  `()-[ùú∂*_x_.._y_]-()` denotes a Path Pattern matching the pattern defined by `ùú∂` at least `_x_` times and at most `_y_` times.
‚Ä¢ A grouping of a Path Pattern +
  `()-[[ùú∂]]-()` denotes a grouping of the pattern `ùú∂`.
‚Ä¢ A specification of direction for a Path Pattern +
  `()-[  ùú∂ >]-()` denotes that the Path Pattern `ùú∂` should be interpreted in a left-to-right direction. +
  `()-[< ùú∂  ]-()` denotes that the Path Pattern `ùú∂` should be interpreted in a right-to-left direction. +
  `()-[< ùú∂ >]-()` denotes that the Path Pattern `ùú∂` should be interpreted in any direction.
‚Ä¢ A reference to a Defined Path Predicate +
  `()-[~alpha]-()` denotes a reference to a Defined Path Predicate named `alpha`.

Binding of a relationship to a variable is only allowed in the most simple case of a Path Pattern, where only a single relationship is matched by the pattern.
For binding a whole path to a variable, Path Assignment should be used, by preceding the path with an identifier and an equals sign (`=`).
This avoids a problem that existed in the past with repetition of relationships (a syntax that is unsupported as of the introduction of Path Patterns), where a relationship variable would bind to a list, making it hard to express predicates over the actual relationships.
Predicates on parts of a Path Pattern are instead expressed through the use of explicitly defined path predicates.

=== Syntax

Path Patterns are part of the Pattern syntax of Cypher.

[source, ebnf]
----
Pattern = PathPattern, {',', PathPattern} ;
PathPattern = [Variable, '='], NodePattern, {PathPattern, NodePattern} ;

NodePattern = '(', [Variable], [NodeLabels], [Properties], ')' ;

PathPattern = (LeftArrowHead, Dash, '[', [PathExpression], ']', Dash, RightArrowHead)
            | (LeftArrowHead, Dash, '[', [PathExpression], ']', Dash)
            | (Dash, '[', [PathExpression], ']', Dash, RightArrowHead)
            | (Dash, '[', [PathExpression], ']', Dash)
            ;

PathExpression  = {PathAlternative} | BoundEdge ;
PathAlternative = PathRepetition, {'|', PathRepetition} ;
PathRepetition  = PathDirected, [('*', [RangeDetail]) | '+' | '?'] ;
PathDirected    = ['<'], PathBase, ['>'] ;
PathBase = PathEdge
         | PathAny
         | PathNode
         | PathReference
         | ('[', PathExpression, ']')
         ;
PathEdge      = (EdgeLabels, [Properties]) | Properties ;
PathAny       = '-' ;
PathNode      = '(', [NodeLabels], [Properties], ')' ;
PathReference = '~', SymbolicName ;

BoundEdge  = Variable, [EdgeLabels], [Properties] ;
EdgeLabels = ':', LabelName, {'|', LabelName} ;
NodeLabels = ':', LabelName, ({':', LabelName} | {'|', LabelName} ;
LabelName  = SymbolicName ;

RangeDetail = [IntegerLiteral | Parameter], '..', [IntegerLiteral | Parameter] ;
----

The `PathReference` is a reference to a Defined Path Predicate.
These are defined using the following syntax:

[source, ebnf]
----
DefinedPathPredicate   = 'PATH', 'PATTERN', DefinedPathName, '=', PathPattern, [Where] ;
DefinedPathName = SymbolicName ;
----


//=== Defined Path Predicates


=== Directions

The direction of relationships matched by a Path Pattern is primarily decided by the directional arrow surrounding the pattern.
If the arrow points from left to right (i.e. `(left)-[~_pattern_]\->(right)`), the paths described by the pattern are paths in the left-to-right direction, i.e. paths that are _outgoing_ from the node to the left of the pattern, and _incoming_ to the node to the right of the pattern.
If the arrow points from right to left (i.e. `(left)\<-[~_pattern_]-(right)`), the paths described by the pattern are paths in the right-to-left paths direction, i.e. paths that are _incoming_ to the node to the left of the pattern, and _outgoing_ from the node to the right of the pattern.
If there are no arrowheads (i.e. `(left)-[~_pattern_]-(right)`), or if both arrowheads are present (i.e. `(left)\<-[~_pattern_]\->(right)`), the paths described by the pattern are paths in either the left-to-right or the right-to-left direction.

All parts of a Path Pattern will assume the direction of the surrounding arrow, unless the direction is explicitly overridden for that particular part of the pattern.
A prefix of `<` to part of a pattern overrides the direction of that part to be right-to-left.
A suffix of `>` to part of a pattern overrides the direction of that part to be left-to-right.
Both a `<` prefix and a `>` suffix can be used on the same part of the pattern to override the direction of that part to be _either direction_.
Direction overrides only apply to a single pattern part.
In order to apply the direction override to multiple parts of the pattern, those parts should be grouped.

Using both a `<` prefix and a `>` suffix on the same pattern is always the same thing as a disjunction between that pattern with a `<` prefix and that pattern with a `>` suffix.
This means that `()-[< ùú∂ >]-()` is the same as `()-[[< ùú∂] | [ùú∂ >]]-()`.

==== Directions and Defined Path Predicates

When a Defined Path Predicate is referenced the direction of reference is matched with the direction in the declaration of the Defined Path Predicate.
If the declaration of the Defined Path Predicate is defined left-to-right, but the direction of the reference is right-to-left, the direction of definition of the the Defined Path Predicate is reversed to match that of the reference.
The same reversal applies if the Defined Path Predicate is defined right-to-left but the direction of the reference is left-to-right.
If the direction of the reference is _either direction_, the Defined Path Predicate is matched both in its declared direction and its reversed direction.
If a Defined Path Predicate is declared without a direction, the direction of the reference does not matter, since the direction of the Defined Path Predicate is inherently _any direction_.
A Defined Path Predicate declared without a direction must have a definition that is equivalent if reversed.

==== Direction examples

‚Ä¢ `()-[a <[b c] d]\->()` is the same as `()-[a]\->()\<-[b c]-()-[d]\->(d)`, i.e. the direction of the group `b c` has been overridden to be right-to-left in a pattern where the overall direction is left-to-right.
‚Ä¢ `()-[a <b> c]\->()` is the same as `()-[a]\->()-[b]-()-[c]\->()`, i.e. the direction of `b` has been overridden to be _either direction_.
‚Ä¢ `()-[a]-()`, `()-[<a>]-()`, `()-[<a>]\->()`, `()\<-[<a>]-()`, `()\<-[<a>]\->()`, and `()\<-[a]\->()` all mean the same thing: matching `a` in _either direction_.

Given these Defined Path Predicates:

[source, cypher]
----
PATH PATTERN alpha = ()-[:X]->()-[:Y]->()
PATH PATTERN beta  = ()<-[:Y]-()<-[:X]-()
PATH PATTERN gamma = ()-[[:X :Y]> | <[:Y :X]]-()
----

‚Ä¢ `()-[~alpha]\->()` is equivalent to `()\<-[~beta]-()`
‚Ä¢ `()\<-[~alpha]-()` is equivalent to `()-[~beta]\->()`
‚Ä¢ `()-[~gamma]\->()` is equivalent to `()\<-[~gamma]-()`, since both are equivalent to `()-[~gamma]-()`
‚Ä¢ `()-[~gamma]-()` is equivalent to `()-[~alpha]-()`, since `()-[~alpha]-()` is the same as `()-[~alpha> | <~alpha]-()`, which is equivalent to the declaration of `gamma`. +
  It is also equivalent to `()-[<~beta | ~beta>]-()` which is the same as `()-[~beta]-()`.

=== Path Pattern Examples

The astute reader of the syntax will have noticed that it is possible to express a Path Pattern with an empty path expression:

[source, cypher]
----
MATCH (a)-[]-(b)
----

The semantics of this query is to match any single relationship between `a` and `b`.
It is thus equivalent to `(a)-[-]-(b)` or `(a)--(b)`.

It is possible to express a completely empty pattern, a pattern that matches `a` and `b` to the same node.
This is done by using only a single node predicate in the path pattern:

[source, cypher]
.A pattern matching a path of length 0
----
MATCH (a)-[()]-(b)
----

This pattern states that `a` and `b` must be the same node, by virtue of stating a pattern that matches any node.
It is thus the same as:

[source, cypher]
----
MATCH (a), (b) WHERE a = b
----

The Path Patterns start becoming interesting when larger expressions are put together:

[source, cypher]
.Finding someone loved by someone hated by someone you know, transitively
----
MATCH (you)-[[:KNOWS :HATES]+ :LOVES]->(someone)
----

Note the `+` expressing one or more occurrences of the sequence `KNOWS` followed by `HATES`.

The direction of each relationship is governed by the overall direction of the Path Pattern.
It is however possible to explicitly define the direction for a particular part of the pattern.
This is done by either prefixing that part with `<` for a right-to-left direction or suffix it with `>` for a left-to-right direction.
It is possible to both prefix the part with `<` and suffix it with `>`, indicating that this part of the pattern matches in any direction.

[source, cypher]
.Specifying the direction for different parts of the pattern
----
MATCH (you)-[[:KNOWS <:HATES]+ :LOVES]->(someone)
----

In the example above we say that the `HATES` relationships should have the opposite direction to the other relationships in the path.

Through the use of Defined Path Predicates we can express even more predicates over a path:

[source, cypher]
.Find a chain of unreciprocated lovers
----
PATH PATTERN unreciprocated_love = (a)-[:LOVES]->(b)
     WHERE NOT EXISTS { (b)-[:LOVES]->(a) }
MATCH (you)-[~unreciprocated_love*]->(someone)
----

Note how there is no colon used for referencing the Defined Path Predicate, the colon is used in Path Patterns only for referencing actual relationship types.

Sometimes it will be interesting to express a predicate on a node in a Path Pattern.
This can be achieved by using a Defined Path Predicate where the nodes on both ends are the same:

[source, cypher]
.Find friends of friends that are not haters
----
PATH PATTERN not_a_hater = (x)
     WHERE NOT EXISTS { (x)-[:HATES]->() }
MATCH (you)-[:KNOWS ~not_a_hater :KNOWS]-(friend_of_friendly_friend)
----

In the case of a Defined Path Predicate where both nodes are the same, the direction of the predicate is irrelevant.
In general the direction of a Defined Path Predicate is quite important, and used for mapping the pattern in the predicate into the Path Patterns that reference it.
The only cases where it is allowed to omit the direction of a Defined Path Predicate is when the defined predicate is reflexive.
This is obviously the case when both nodes are the same, but it would also be the case when the internal pattern is symmetrical, such as in the following example:

[source, cypher]
.Find chains of co-authorship
----
PATH PATTERN co_author = (a)-[:AUTHORED]->(:Book)<-[:AUTHORED]-(b)
MATCH (you)-[~co_author*]-(someone)
----


=== Expressive power

==== Compared to GXPath

===== Path expressions

[options="header"]
|=================
|| GXPath | Cypher

| The empty pattern, from a node to itself, via nothing.
| `‚ü¶Œµ‚üß^G^ = {(v,v) \| v ‚àà V}`
| `(v)-[()]-(v)`

| Match an edge with any label.
| `‚ü¶_‚üß^G^ = {(v,w) \| ‚àÉ a : (v,a,w) ‚àà E}`
| `(v)-[-]\->(w)`

| Match edge with a given label.
| `‚ü¶a‚üß^G^ - {(v,w) \| (v,a,w) ‚àà E}`
| `(v)-[:a]\->(w)`

| Inverted direction of an edge.
| `‚ü¶a-‚üß^G^ = {(v,w) \| (w,a,v) ‚àà E}`
| `(v)-[<:a]\->(w)`

| Match ùú∂ 0 or more times.
| `‚ü¶ùú∂*‚üß^G^ =` reflexive transitive closure of `ùú∂`
| `()-[ùú∂*]\->()`

| Match ùú∂ followed by ùõΩ.
| `‚ü¶ùú∂ ¬∑ ùõΩ‚üß^G^ = ‚ü¶ùú∂‚üß^G^ ‚∏∞ ‚ü¶ùõΩ‚üß^G^`
| `()-[ùú∂ ùõΩ]\->()`

| Disjunction. Either match ùú∂ or match ùõΩ.
| `‚ü¶ùú∂ ‚à™ ùõΩ‚üß^G^ = ‚ü¶ùú∂‚üß^G^ ‚à™ ‚ü¶ùõΩ‚üß^G^`
| `()-[ùú∂\|ùõΩ]\->()`

| Any pair of nodes _not_ reachable via ùú∂.
| `‚ü¶¬¨ùú∂‚üß^G^ = V ‚®Ø V - ‚ü¶ùú∂‚üß^G^`
| *_not supported_* +
  _Path Patterns have to match a continuous path in the graph._

| Node matching a given Node Predicate.
| `‚ü¶[ùùã]‚üß^G^ = {(v,v) \| v ‚àà ‚ü¶ùùã‚üß^G^}`
| `PATH PATTERN phi = (v) WHERE ùùã +
   MATCH ()-[~phi]\->()`

| Repeat pattern ùú∂ between `n` and `m` times.
| `‚ü¶ùú∂^n,m^‚üß^G^ = ‚ãÉ~k=n~^m^(‚ü¶ùú∂‚üß^G^)k`
| `()-[ùú∂*n..m]\->()`

| Path through ùú∂, where data value of origin node is equal to value at destination node.
| `‚ü¶ùú∂=‚üß^G^ = {(v,w) ‚àà ‚ü¶ùú∂‚üß^G^ \| ùúå(v)=ùúå(w)}`
| `PATH PATTERN alpha_eq = (v)-[ùú∂]\->(w) WHERE v.ùúå = w.ùúå +
   MATCH ()-[~alpha_eq]\->()`

| Path through ùú∂, where data value of origin node differs from value at destination node.
| `‚ü¶ùú∂‚â†‚üß^G^ = {(v,w) ‚àà ‚ü¶ùú∂‚üß^G^ \| ùúå(v)‚â†ùúå(w)}`
| `PATH PATTERN alpha_not_eq = (v)-[ùú∂]\->(w) WHERE v.ùúå <> w.ùúå +
   MATCH ()-[~alpha_not_eq]\->()`

| Conjunctions (not in _GXPath_, allows CRPQs)

  Note that in this case Cypher requires one of the patterns needs to be chosen as the _main_ pattern, this is the pattern that will be seen when binding the matched path.
| `‚ü¶ùú∂ ‚à© ùõΩ‚üß^G^ = ‚ü¶ùú∂‚üß^G^ ‚à© ‚ü¶ùõΩ‚üß^G^`
| `PATH PATTERN alpha_and_beta = (v)-[ùú∂]\->(w) WHERE EXISTS { (v)-[ùõΩ]\->(w) } +
   MATCH ()-[~alpha_and_beta]\->()`
|=================

===== Node Predicates

[options="header"]
|=================
|| GXPath | Cypher

| Node has a path matching a path expression.
| `‚ü¶‚ü®ùú∂‚ü©‚üßG = {v \| ‚àÉ w : (v,w) ‚àà ‚ü¶ùú∂‚üß^G^}`
| `PATH PATTERN has_alpha = (v) WHERE EXISTS { (v)-[ùú∂]\->() }`

| Negation of predicate.
| `‚ü¶¬¨ùùã‚üß^G^ = V - ‚ü¶ùùã‚üß^G^`
| `PATH PATTERN not_phi = (v) WHERE NOT ùùã`

| Conjunction of predicates.
| `‚ü¶ùùã ‚àß ùúì‚üß^G^ = ‚ü¶ùùã‚üß^G^ ‚à© ‚ü¶ùúì‚üß^G^`
| `PATH PATTERN phi_and_psi = (v) WHERE ùùã AND ùúì`

| Disjunction of predicates.
| `‚ü¶ùùã ‚à® ùúì‚üß^G^ = ‚ü¶ùùã‚üß^G^ ‚à™ ‚ü¶ùúì‚üß^G^`
| `PATH PATTERN phi_or_psi = (v) WHERE ùùã OR ùúì`

| Value equal to constant.
| `‚ü¶c=‚üß^G^ = {v ‚àà V \| ùúå(v) = c}`
| `PATH PATTERN rho_is_c = (v) WHERE v.ùúå = c`

| Value not equal to constant.
| `‚ü¶c‚â†‚üß^G^ = {v ‚àà V \| ùúå(v) ‚â† c}`
| `PATH PATTERN rho_is_not_c = (v) WHERE v.ùúå <> c`

| Value reachable from node by path ùú∂ equal to value reachable by path ùõΩ.
| `‚ü¶‚ü®ùú∂ = ùõΩ‚ü©‚üß^G^ = {v ‚àà V \| ‚àÉ w, y : (v, w) ‚àà ‚ü¶ùú∂‚üß^G^, (v, y) ‚àà ‚ü¶ùõΩ‚üß^G^, ùúå(w)=ùúå(y)}`
| `PATH PATTERN alpha_eq_beta = (v) WHERE EXISTS { (v)-[ùú∂]\->(w), (v)-[ùõΩ]\->(y) WHERE w.ùúå = y.ùúå }`

| Value reachable from node by path ùú∂ differs from value reachable by path ùõΩ.
| `‚ü¶‚ü®ùú∂ ‚â† ùõΩ‚ü©‚üß^G^ = {v ‚àà V \| ‚àÉ w, y : (v, w) ‚àà ‚ü¶ùú∂‚üß^G^, (v, y) ‚àà ‚ü¶ùõΩ‚üß^G^, ùúå(w)‚â†ùúå(y)}`
| `PATH PATTERN alpha_not_eq_beta = (v) WHERE EXISTS { (v)-[ùú∂]\->(w), (v)-[ùõΩ]\->(y) WHERE w.ùúå <> y.ùúå }`
|=================

==== Compared to Regular Expressions With Memory (REMs)

// page 53 of Querying Graphs with Data (PhD) - 5.4 Regular queries with binding (RQBs)

Regular Expressions with Memory does not have bounded scope for the memory of variables, since it is an algebra designed to model a register automata.
An alternative that _does_ have lexical scoping is called _Regular Expressions with Binding_, and is proven to be a subset of Regular Expressions with Memory, fully translatable to Regular Expressions with Memory.
Regular Expressions with Binding is thus more in line with what an actual language would express, and possible to map to Cypher.

In the table below `ùë£` is partial function from a variable `x` to the memory domain `ùíü`.

[options="header"]
|=================
|| Regular Expressions with Binding | Cypher

| Empty path.
| `‚ü¶Œµ, ùë£‚üß^G^ = {(v, v) \| v ‚àà V }`
| `(v)-[()]-(v)`

| Single edge.
| `‚ü¶a, ùë£‚üß^G^ = {(v, w) \| (v, a, w) ‚àà E }`
| `(v)-[:a]->(w)`

| Inversion of single edge.
| `‚ü¶a^-^, ùë£‚üß^G^ = {(v, w) \| (w, a, v) ‚àà E }`
| `(v)-[<:a]->(w)`

| Concatenation.
| `‚ü¶ùú∂ ¬∑ ùõΩ, ùë£‚üß^G^ = ‚ü¶ùú∂, ùë£‚üß^G^ ‚∏∞ ‚ü¶ùõΩ, ùë£‚üß^G^`
| `(v)-[ùú∂ ùõΩ]->(w)`

| Disjunction.
| `‚ü¶ùú∂ ‚à™ ùõΩ, ùë£‚üß^G^ = ‚ü¶ùú∂, ùë£‚üß^G^ ‚à™ ‚ü¶ùõΩ, ùë£‚üß^G^`
| `(v)-[ùú∂ \| ùõΩ]->(w)`

| Transitive closure.
| `‚ü¶ùú∂^+^, ùë£‚üß^G^ =` transitive closure of `‚ü¶ùú∂, ùë£‚üß^G^`
| `(v)-[ùú∂+]->(w)`

| Data value (and memory state ùë£) matching condition `c`.
| `‚ü¶ùú∂[c], ùë£‚üß^G^ = {(v, w) \| (v, w) ‚àà ‚ü¶ùú∂, ùë£‚üß^G^, (ùúå(w),ùë£)‚ä®c }`
| `(v)-[ùú∂]->(w) WHERE c`

| Assignment of variable.
| `‚ü¶‚Üì[overline]#x#.{ùú∂}, ùë£‚üß^G^ = {(v,w ) \| (v, w) ‚àà ‚ü¶ùú∂, ùë£Ôºª[overline]#x# = ùúå(v)ÔºΩ‚üß^G^}`
| `PATH PATTERN alpha_scope = (v)-[ùú∂]\->(w)`
|=================

Note that in the assignment case in Cypher, the scope of the variables is within a single Defined Path Predicate.
Internal references to other Defined Path Predicates will not have those variables in scope.
It is thus important for the expressive power that the other composition rules above do not need to be expressed through Defined Path Predicates.
Even so the expressive power in terms of variable scope is less in Cypher than it is in Regular Expressions with Binding, since there are no nested scopes in Cyphers Defined Path Predicates.


==== Compared to Context Free Languages

The Defined Path Predicates of the Cypher Path Patterns allow the definition of what amounts to a context free language over paths in the graph.
Here we will show that type of compositions possible in a context free grammar, have corresponding constructs in Cypher.

In the Context Free Grammar column below, upper case latin characters are used to denote non-terminal symbols, lower case latin characters denote terminal symbols, and greek characters are used to denote strings of non-terminal or terminal symbols.

[options="header"]
|=================
|| Context Free Grammar | Cypher

| Empty production
| `A -> Œµ`
| `PATH PATTERN A = ()-[()]\->()`

| Terminal productions
| `A -> a`
| `PATH PATTERN A = ()-[:a]\->()`

| Disjunctions, i.e. Alternatives
| `A -> ùú∂ \| ùõΩ`
| `PATH PATTERN A = ()-[ùú∂ \| ùõΩ]\->()`

| Concatenation
| `A -> ùú∂ ùõΩ`
| `PATH PATTERN A = ()-[ùú∂ ùõΩ]\->()`

| Transitive closure
| `A -> ùú∂*`
| `PATH PATTERN A = ()-[ùú∂*]\->()`
|=================

This allows path patterns that match paths that are typically considered context free, such as balanced pairs:

[source, cypher]
.Find cousins at any distance (where siblings are zeroth cousins)
----
PATH PATTERN cousin = ()-[:PARENT> [ ~cousin | ()] <:PARENT]-()
MATCH (me)-[~cousin]-(my_cousin)
RETURN me, collect(my_cousin) AS cousins
// now all we need is you and your cousins, and we have a song by Vampire Weekend
----
