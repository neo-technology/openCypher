= CIP2016-06-22 Nested, updating, and chained subqueries
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Petra Selmer <petra.selmer@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
Cypher currently has no support for nested subqueries.
This is limiting as it prevents e.g. post-processing of union results or changing the working graph via a subquery.
This CIP proposes to add support for nested subqueries and composite statements to Cypher.
Nested subqueries may be uncorrelated (take no input records), correlated (take input records), produce tables, graphs, or have side-effects (i.e. perform updates).
--

toc::[]



== Introduction


=== Motivation

Subqueries - i.e. queries within queries - are a powerful and expressive feature allowing for:

  * Increased query expressivity
  * Better query construction and readability
  * Easier composition of simple query pipelines
  * Post-processing results from multiple queries as a single unit
  * Performing a sequence of multiple write commands for each record


=== Background

This CIP has been created in tandem with CIP2017-06-18 for adding support for working with multiple graphs to Cypher and relies on the terminology for describing the high-level structure of queries introduced in CIP2017-06-18.
Therefore this proposal is based on the assumption that CIP2017-06-18 will be accepted.

This CIP should also be viewed in light of CIPs for set operations, `EXISTS`, scalar subqueries, and list subqueries.

=== Design goals

This proposal follows the following design goals

1. Ensure that subqueries have the exact same capabilities in terms of consumed inputs, produces outputs, and potential side-effects as regular standalone queries.

2. Ensure that every subquery is a syntactically valid standalone query independent of which variables are provided by the calling context.



== Proposal

Subqueries are self-contained Cypher queries that are usually run within the scope of an outer Cypher query.

This proposal suggests the introduction of new subquery constructs to Cypher.

* Nested tabular subqueries
** Nested tabular subqueries of the form `CALL { <subquery> }`
** Optional nested tabular subqueries of the form `OPTIONAL CALL { <subquery> }`
** Mandatory nested tabular subqueries of the form `MANDATORY CALL { <subquery> }`
** Grouped nested tabular subqueries
* Nested graph subqueries
** Create graph subqueries of the form `CREATE GRAPH <graph-name> { <subquery> }, <graph-name> { <subquery> }, ...`
** Read graph subqueries of the form `FROM { <subquery> }`
** Update graph subqueries of the form `UPDATE { <subquery> }`
* Syntactic simplifications
** Composite statements
** Conditional nested subqueries

Both uncorrelated and correlated forms of nested subqueries are supported by this CIP.

This proposal additional suggests removing the `FOREACH` clause from the current language (it is rendered obsolete by the introduction of nested tabular subqueries).


== Nested subqueries

Nested subqueries are always introduced with keywords that are followed by an inner query in curly braces.

_Definition_: A *nested subquery* is a composite statement that syntactically occurs as an argument to another clause that is enclosed in curly braces.

Usage of nested subqueries must adhere to the following rules:

1. Nested subqueries can be contained within other nested subqueries at an arbitrary (but finite) depth.
2. Nested subqueries that perform updates cannot be contained within nested subqueries in read-only contexts.
3. Nested subqueries are not allowed to contain schema commands

Note:: These restrictions capture current use of Cypher and may be reduced in the future.

Nested subqueries may be correlated - i.e. the inner query may use variables from the outer query - or uncorrelated.

_Definition_: A *correlated nested subquery* is a *nested subquery* that has at least one leading clause that is a `WITH` clause that references a variable from a preceding clauses.

_Definition_: An *uncorrelated nested subquery* is a *nested subquery* that has no leading clause that is a `WITH` clause that references a variable from the preceding clauses.

A composite statement that is used as a nested subquery may have multiple points of entry.
The following definition captures this concept of entry points into a subquery by using the terminology introduced in CIP2017-06-18:

_Definition_: The *leading clauses* of a composite statement are the leading clauses of the first single statement.
The leading clauses of a single statement are the leading clauses of its constituents.
The leading clause of a simple clause chain is the first clause in the sequence of clauses unless that clause is a call to a nested subquery in which case the leading clauses of the simple clause chain will be taken to be the leading clauses of that nested subquery.
The leading clauses of an operator clause chain are the leading clauses of all simple clause chains that are connected directly by the operator clause of the operator clause chain.


=== Nested table subqueries

A nested table subquery is evaluated for each incoming input record and may produce an arbitrary number of output records.

_Definition_: A *nested table subquery* is a composite statement that returns a table.

We extend `CALL` with a new syntactic form that allows a nested table subquery argument and may be used either in a stand-alone call or inside a simple clause chain.

[source, cypher]
----
-- preceding clauses
...
CALL {
  -- nested table subquery
  ...
}
-- remaining clauses
...
----


[#uncorrelated-subqueries]
==== Uncorrelated nested table subqueries

Semantics:

1. The nested table subquery is executed for each record produced by preceding clauses.
This record is called the *input record* in this context.
No variable bindings are made available to the nested subquery.
This rule is relaxed for <<correlated-subqueries>>.

2. If the nested table subquery returns nothing (i.e. ends in an updating command), then all input records are passed on to the remaining clauses.

3. If the nested table subquery returns tabular data, each input record produced by preceding clauses is combined with each record returned by calling the nested subquery for that input record to produce result records.
All such result records are passed on as input to the remaining query.

4. An error is raised if the nested table subquery produces a tabular result that binds a variable that is already bound in the outer query.
This rule is relaxed for <<correlated-subqueries>>.

5. Any change to the working graph during the execution of the nested table subquery is not visible to the remaining clauses.
In other words, the working graph is duplicated on the working graph stack when calling a nested table subquery and the working graph is removed from the working graph stack when consuming the result of calling a nested table subquery.


[#correlated-subqueries]
==== Correlated nested table subqueries

Correlated nested table subqueries refer to variable bindings from preceding clauses.
Syntactically, this is achieved by using the `WITH` clause as a leading clause of the nested table subquery that declares required inputs in terms of available variables from preceding clauses.

Semantics:

1. All rules for <<uncorrelated-subqueries>> apply for correlated nested table subqueries unless otherwise noted in this list.

2. All variable bindings of the input record are made available to all leading clauses of the nested table subquery.

3. The nested subquery may return variables already bound by preceding clauses if it can be shown via simple static analysis that these have just been passed through.
It is not required that this analysis takes into account aliasing inside the nested subquery.


=== Optional nested table subqueries and procedure calls

A nested table subquery may be prefixed with the keyword `OPTIONAL`.

If calling the nested table subquery returns an empty result, this empty result is replaced with a table that consists of a single record that maps all variables that have been newly introduced by the the nested table subquery to `NULL` and all variables that have been passed through by the nested table subquery to their value in the input record.

An implementation may choose to support the same semantics for calling procedures using syntax like `OPTIONAL CALL myProc(...) YIELD ...`.


=== Mandatory nested table subqueries and procedure calls

A nested table subquery may be prefixed with the keyword `MANDATORY`.

If calling the nested table subquery returns an empty result, an error is raised.

The same semantics are supported for calling procedures using syntax like `MANDATORY CALL myProc(...) YIELD ...`.

// UP TO HERE


=== Read-only nested subqueries

In all instances below, `<inner-query>` denotes any complete, read-only Cypher query.

==== Read-only nested regular subqueries

We propose the addition of read-only nested regular subqueries as a new form of read-only Cypher query.

A nested read-only simple subquery is denoted using the following syntax: `MATCH { <inner-query> }`.

==== Read-only nested optional subqueries

We propose extending the `OPTIONAL MATCH` clause to express read-only nested optional subqueries.

A read-only nested optional subquery is denoted by the following syntax: `OPTIONAL MATCH { <inner-query> }`.

==== Read-only nested mandatory subqueries

We propose extending the `MANDATORY MATCH` clause to express read-only nested mandatory subqueries.

A read-only nested mandatory subquery is denoted by the following syntax: `MANDATORY MATCH { <inner-query> }`.

==== Semantics

The nested subquery will be provided with all variables visible in the outer query as input.

Each record returned by the final `RETURN` clause of the subquery augments the variable bindings of the initial input record from the outer query to form an output record of the subquery.
This may shadow existing bindings of the initial input record.
No other variable bindings are added to output records.

Note:: It is recommended that implementations generate a warning if an incoming variable is both discarded within the inner query while the same inner query also returns a (potentially different) value for that variable to the outer query, i.e. is shadowing (replacing) it.

Finally, the result records of the different forms of nested subqueries are formed as follows:

* The result records of a read-only regular subquery are just the output records.
* The result records of a read-only optional subquery are all the output records (if there is at least one output record), or a single record with the same fields as the output records where all newly-introduced variable bindings are set to `NULL`.
* The result records of a read-only mandatory subquery are just the output records. However, if the set of output records is empty, an error is raised in the same way as regular `MANDATORY MATCH` raises an error when no matches are found.

Nested subqueries interact with write clauses in the same way that `MATCH` does.


=== Read/Write updating subqueries

Updating subqueries never change the cardinality; i.e. the inner update query is run for each incoming input record.

==== Read/Write simple updating subqueries

We propose the addition of a new `DO` clause for expressing read/write simple updating subqueries that _do not return any data_ from the inner query to the outer query.

A read/write simple updating subquery is denoted by the following syntax: `DO { <inner-update-query> }`.

Any updating Cypher query from which the trailing final `RETURN` clause has been omitted may be used as an inner update query.

A query may end with a `DO` subquery in the same way that a query can currently end with any update clause.

==== Read/Write conditionally-updating subqueries

We propose the addition of a new conditional `DO` clause for expressing read/write conditionally-updating subqueries that _do not return any data_ from the inner query to the outer query.

A read/write conditionally-updating subquery is denoted by the following syntax:

```
DO
  [WHEN <predicate> THEN <inner-update-query>]+
  [ELSE <inner-update-query>]
END
```

Evaluation proceeds as follows:

* Semantically, the `WHEN` predicates are tested in the order given, and the inner updating query is executed only for the first predicate that evaluates to `true`.
* If no given `WHEN` predicate evaluates to `true` and an `ELSE` branch is provided, the inner updating query of the `ELSE` branch is executed.
* If no given `WHEN` predicates evaluates to `true` and no `ELSE` branch is provided, no updates will be executed.

A query may end with a conditional `DO` subquery in the same way that a query can currently end with an update clause.


=== Chained subqueries

Chained subqueries are queries that compose a top-level result query using a sequence of _query combinator_ clauses each followed by a query component.

A query component is a sequence of clauses that either describes an updating query or a read-only that ends in a `RETURN` clause but does not contain any top-level query combinator clauses.
Query components may however contain nested subqueries whose inner queries contain query combinator clauses.

Currently Cypher only supports the `UNION` and `UNION ALL` query combinators.
This CIP proposes to extend this set of query combinators with new forms as outlined below.


==== Chained data-dependent subqueries

We propose the introduction of using the `WITH` projection clause as a new query combinator that can sequentially compose arbitrary queries to form a chained data-dependent subquery without having to resort to nesting and indentation (e.g. as a short-hand syntax for post-UNION processing).

Chained data-dependent subqueries have the following general form `<Q1> WITH ... <Q2>`.

Both `<Q1`> and `<Q2>` are arbitrary query components.

Conceptually, the query `<Q2>` is evaluated for each incoming input record from the query `<Q1>` and may produce an arbitrary number of result records.
In other words, the query `<Q2>` will be provided with all variables returned by the query `<Q1>` as input variable bindings.

Furthermore, this CIP proposes allowing a leading `WITH` to project new variables from expressions that refer to unbound variables from the preceding scope (or query).
This set of referenced, unbound variables of such a leading `WITH` is understood to implicitly declare the input variables required for the query to execute.

Note:: This mechanism allows composing a Cypher query with inputs that have been constructed programmatically.

==== Chained data-independent subqueries

We propose introducing the `THEN` projection clause as a new query combinator that can sequentially compose two arbitrary subqueries to form a chained data-independent subquery without having to resort to nesting and indentation.

Chained data-independent subqueries have the following general form `<Q1> THEN <Q2>`.

Both `<Q1`> and `<Q2>` are query components.
No variables and no input records are passed from `<Q1>` to `<Q2>`.
Instead `<Q2>` is executed in a standalone fashion after the execution of `<Q1>` has finished.

Furthermore, this CIP proposes allowing queries to start with a leading `THEN` for discarding all variables in scope as well as the cardinality of all input records provided by the surrounding execution environment.

Note:: This mechanism allows guaranteed execution of an (usually updating) query `<Q2>` irrespective of the number of records produced by query `<Q1>`.

Note:: In general, `<Q1>` is expected to be an updating query and it is recommended that implementations generate a warning if this is not the case (to inform the user that `<Q1>` is essentially superfluous).

==== Query combinator precedence

This CIP proposes that all Cypher query combinators are left-associative regarding their left-hand side and right-hand side input queries.

Note:: In other words, `<Q1> UNION <Q2> WITH <Q3>` is always interpreted as  `(<Q1> UNION <Q2>) WITH <Q3>` but never as `<Q1> UNION (<Q2> WITH <Q3>)` (The same rule applies to `THEN`).

==== Discarding variables in scope

Finally, this CIP proposes new shorthand syntax for discarding all variables in scope without discarding the cardinality of input records using `WITH|RETURN|YIELD NOTHING`.

=== Examples

==== Read-only nested regular subqueries

Post-UNION processing:
[source, cypher]
----
MATCH {
  // authored tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:AUTHORED]-(tweet:Tweet)
  RETURN tweet, tweet.time AS time, user.country AS country
  UNION
  // favorited tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:HAS_FAVOURITE]-(favorite:Favorite)-[:TARGETS]->(tweet:Tweet)
  RETURN tweet, favourite.time AS time, user.country AS country
}
WHERE country = 'se'
RETURN DISTINCT tweet
ORDER BY time DESC
LIMIT 10
----

Uncorrelated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  RETURN b.name AS name, v.code AS code
}
RETURN f, name, code
----

Correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})-[:IS_IN]->(country:Country)
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b.name AS name, v.code AS code
}
RETURN f, name, code
----

Filtered and correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm)-[:IS_IN]->(country:Country)
WHERE country.name IN $countryNames
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b AS brand, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b AS brand, v.code AS code
}
WHERE f.type = 'organic'
  AND b.certified
RETURN f, brand.name AS name, code
----

Doubly-nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (c:Customer)-[:BUYS_FOOD_AT]->(f)
  MATCH {
     MATCH (c)-[:RETWEETS]->(t:Tweet)<-[:TWEETED_BY]-(f)
     RETURN c, count(*) AS count
     UNION
     MATCH (c)-[:LIKES]->(p:Posting)<-[:POSTED_BY]-(f)
     RETURN c, count(*) AS count
  }
  RETURN c, 'customer' AS type, sum(count) AS endorsement
  UNION
  MATCH (s:Shop)-[:BUYS_FOOD_AT]->(f)
  MATCH (s)-[:PLACES]->(a:Advertisement)-[:ABOUT]->(f)
  RETURN s, 'shop' AS type, count(a) * 100 AS endorsement
}
RETURN f.name AS name, type, sum(endorsement) AS endorsement
----

===== Read-only nested optional and mandatory subqueries

This proposal also provides nested subquery forms of `OPTIONAL MATCH` and `MANDATORY MATCH`:

[source, cypher]
----
MANDATORY MATCH (p:Person {name: 'Petra'})
MANDATORY MATCH (conf:Conference {name: $conf})
MANDATORY MATCH {
    WITH * WHERE conf.impact > 5
    MATCH (p)-[:ATTENDS]->(conf)
    RETURN conf
    UNION
    MATCH (p)-[:LIVES_IN]->(:City)<-[:IN]-(conf)
    RETURN conf
}
OPTIONAL MATCH {
    MATCH (p)-[:KNOWS]->(a:Attendee)-[:PUBLISHED_AT]->(conf)
    RETURN a.name AS name
    UNION
    MATCH (p)-[:KNOWS]->(a:Attendee)-[:PRESENTED_AT]->(conf)
    RETURN a.name AS name
}
RETURN name
----


==== Read/Write simple updating and conditionally-updating subqueries

We illustrate these by means of an 'old' version of the query, in which `FOREACH` is used, followed by the 'new' version, using `DO`.

Using a single subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH(x IN range(1, 10) |
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
)
----

Using a single subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO {
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
}
----

Note how `FOREACH` is addressing two semantic concerns simultaneously; namely looping, and performing updates without affecting the cardinality of the outer query.
In the new version of the query shown above, these orthogonal concerns have been separated.
Looping is already handled by `UNWIND`, while `DO` suppresses the increased cardinality from the inner query.

`DO` also hides all new variable bindings introduced by the inner query from the outer query.
If `DO` is omitted from the new version of the query shown above, the variable `c` would become visible to the remainder of the query.

Doubly-nested subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH (x IN range(1, 10) |
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  FOREACH (y IN range(1, 10) |
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  )
)
----

Doubly-nested subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x AS x
DO {
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  UNWIND range(1, 10) AS y
  DO {
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  }
}
----

Conditional `DO`
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO WHEN x % 2 = 1 THEN {
      MERGE (c:Odd:Child {id: x})
      MERGE (r)-[:PARENT]->(c)
  }
  ELSE {
      MERGE (c:Even:Child {id: x})
      MERGE (r)-[:PARENT]->(c)
  }
END
----

==== Chained subqueries

Combining nested and chained subqueries
[source, cypher]
----
MATCH (x)-[:IN]->(:Category {name: "A"})
WITH x LIMIT 5
MATCH (x)-[:FROM]-(c :City)
RETURN x, c
UNION
MATCH (x)-[:IN]->(:Category {name: "A"})
WITH x LIMIT 10
MATCH (x)-[:FROM]-(c :City)
// This finished the right arm of the UNION
RETURN x, c
// This applies to the whole UNION
WITH x.name AS name ORDER BY x.age
RETURN x LIMIT 10
----

=== Interaction with existing features

Apart from the suggested deprecation of the `FOREACH` clause, nested read-only, write-only and read-write subqueries do not interact directly with any existing features.

== Alternatives

Alternative syntax has been considered during the production of this document:

  * Using round braces; i.e. `MATCH (...)`
  * Using alternative keywords:

    ** `SUBQUERY`
    ** `QUERY`

== What others do

=== SQL

The following types of subqueries are supported in SQL:

Scalar:
[source, cypher]
----
SELECT orderID
FROM Orders
WHERE orderID =
  (SELECT max(orderID) FROM Orders)
----

Multi-valued:
[source, cypher]
----
SELECT customerID
FROM Customers
WHERE customerID IN
  (SELECT customerID FROM Orders)
----

Correlated:
[source, cypher]
----
SELECT orderID, customerID
FROM Orders AS O1
WHERE orderID =
  (SELECT max(O2.orderID) FROM Orders AS O2
   WHERE O2.customerID = O1.customerID)
----

Table-valued/table expression:
[source, cypher]
----
SELECT orderYear
FROM
  (SELECT YEAR(orderDate) AS orderYear
  FROM Orders) AS D
----

Scalar and list subqueries are addressed in the Scalar Subqueries and List Subqueries CIP.

=== SPARQL

https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#subqueries[SPARQL] supports uncorrelated subqueries in the standard, exemplified by:

[source, cypher]
----
SELECT ?y ?minName
WHERE {
  :alice :knows ?y .
 {
    SELECT ?y (MIN(?name) AS ?minName)
    WHERE {
      ?y :name ?name .
    } GROUP BY ?y
  }
}
----

Owing to the bottom-up nature of SPARQL query evaluation, the supported forms of subqueries are evaluated logically first, and the results are projected up to the outer query.
Variables projected out of the subquery will be visible, or in scope, to the outer query.


== Benefits to this proposal

* Increasing the expressivity of the language.
* Allowing unified post-processing on results from multiple (sub)queries; this is exemplified by the https://github.com/neo4j/neo4j/issues/2725[request for post-UNION processing].
* Facilitating query readability, construction and maintainability.
* Providing a feature familiar to users of SQL.

== Caveats to this proposal

At the current time, we are not aware of any caveats.
