= CIP2016-06-22 - Nested, updating, and chained subqueries
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Petra Selmer <petra.selmer@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP proposes the incorporation of nested, updating, and chained subqueries into Cypher.
--

toc::[]


== Motivation

Subqueries - i.e. queries within queries - are a powerful and expressive feature allowing for:

  * Increased query expressivity
  * Better query construction and readability
  * Easier composition of simple query pipelines
  * Post-processing results from multiple queries as a single unit
  * Performing a sequence of multiple write commands for each record

== Background

This CIP may be viewed in light of CIPs for query combinators and set operations, `EXISTS`, scalar subqueries, and list subqueries.

== Proposal

Subqueries are self-contained Cypher queries that are usually run within the scope of an outer Cypher query.

This proposal suggests the introduction of new subquery constructs to Cypher.

* Read-only nested subqueries
** Read-only nested regular subqueries of the form `MATCH { <reading-query> }`
** Read-only nested optional subqueries of the form `OPTIONAL MATCH { <reading-query> }`
** Read-only nested mandatory subqueries of the form `MANDATORY MATCH { <reading-query> }`
* Read/Write updating subqueries
** Read/Write simple updating subqueries of the form `DO { <updating-query> }` (the inner query not ending with `RETURN`)
** Read/Write conditionally-updating subqueries of the form `DO [WHEN <predicate> THEN { <updating-query> }]+ [ELSE { <updating-query> }] END` (the inner queries not ending with `RETURN`)
* Chained subqueries
** Chained _data-dependent_ subqueries that extend the `WITH` projection clause with the form `<query> <with-clause> <query>`. Additionally, this CIP proposes new shorthand syntax for starting a query with `WITH` to compose a query with external inputs.
** Chained _data-independent_ subqueries based on the newly-introduced `THEN` clause for discarding all variables in scope as well as the cardinality of all input records. Additionally, this CIP proposes new shorthand syntax for discarding all variables in scope without discarding the cardinality of input records using `WITH|RETURN|YIELD NOTHING`.

We additionally propose removing the `FOREACH` clause from the current language (it is rendered obsolete by the introduction of `DO`).

Subquery constructs are always introduced with a keyword(s) in conjunction with an inner query in curly braces.

Subqueries may be correlated - i.e. the inner query may use variables from the outer query - or uncorrelated.

Subqueries can be contained within other subqueries at an arbitrary (but finite) depth.

Read/Write subqueries cannot be contained within other read-only subqueries.


=== Read-only nested subqueries

A nested subquery is evaluated for each incoming input record and may produce an arbitrary number of output records.

In all instances below, `<inner-query>` denotes any complete, read-only Cypher query.

==== Read-only nested regular subqueries

We propose the addition of read-only nested regular subqueries as a new form of read-only Cypher query.

A nested read-only simple subquery is denoted using the following syntax: `MATCH { <inner-query> }`.

==== Read-only nested optional subqueries

We propose extending the `OPTIONAL MATCH` clause to express read-only nested optional subqueries.

A read-only nested optional subquery is denoted by the following syntax: `OPTIONAL MATCH { <inner-query> }`.

==== Read-only nested mandatory subqueries

We propose extending the `MANDATORY MATCH` clause to express read-only nested mandatory subqueries.

A read-only nested mandatory subquery is denoted by the following syntax: `MANDATORY MATCH { <inner-query> }`.

==== Semantics

The nested subquery will be provided with all variables visible in the outer query as input.

Each record returned by the final `RETURN` clause of the subquery augments the variable bindings of the initial input record from the outer query to form an output record of the subquery.
This may shadow existing bindings of the initial input record.
No other variable bindings are added to output records.

Note:: It is recommended that implementations generate a warning if an incoming variable is both discarded within the inner query while the same inner query also returns a (potentially different) value for that variable to the outer query, i.e. is shadowing (replacing) it.

Finally, the result records of the different forms of nested subqueries are formed as follows:

* The result records of a read-only regular subquery are just the output records.
* The result records of a read-only optional subquery are all the output records (if there is at least one output record), or a single record with the same fields as the output records where all newly-introduced variable bindings are set to `NULL`.
* The result records of a read-only mandatory subquery are just the output records. However, if the set of output records is empty, an error is raised in the same way as regular `MANDATORY MATCH` raises an error when no matches are found.

Nested subqueries interact with write clauses in the same way that `MATCH` does.


=== Read/Write updating subqueries

Updating subqueries never change the cardinality; i.e. the inner update query is run for each incoming input record.

==== Read/Write simple updating subqueries

We propose the addition of a new `DO` clause for expressing read/write simple updating subqueries that _do not return any data_ from the inner query to the outer query.

A read/write simple updating subquery is denoted by the following syntax: `DO { <inner-update-query> }`.

Any updating Cypher query from which the trailing final `RETURN` clause has been omitted may be used as an inner update query.

A query may end with a `DO` subquery in the same way that a query can currently end with any update clause.

==== Read/Write conditionally-updating subqueries

We propose the addition of a new conditional `DO` clause for expressing read/write conditionally-updating subqueries that _do not return any data_ from the inner query to the outer query.

A read/write conditionally-updating subquery is denoted by the following syntax:

```
DO
  [WHEN <predicate> THEN <inner-update-query>]+
  [ELSE <inner-update-query>]
END
```

Evaluation proceeds as follows:

* Semantically, the `WHEN` predicates are tested in the order given, and the inner updating query is executed only for the first predicate that evaluates to `true`.
* If no given `WHEN` predicate evaluates to `true` and an `ELSE` branch is provided, the inner updating query of the `ELSE` branch is executed.
* If no given `WHEN` predicates evaluates to `true` and no `ELSE` branch is provided, no updates will be executed.

A query may end with a conditional `DO` subquery in the same way that a query can currently end with an update clause.


=== Chained subqueries

_Chained_ subqueries are queries that compose a top-level result query using a _query combinator_ clause from two input queries: a left-hand side 'top-level' query and a right-hand side argument query.

In this definition, top-level queries are arbitrary Cypher queries, while argument queries are queries that may *not* contain query combinators.
Argument queries may however contain nested subqueries whose inner queries again may be top-level queries (that may very well contain query combinators).

Currently Cypher only supports the `UNION` and `UNION ALL` query combinators.
This CIP proposes to extend this set of query combinators with new forms as outlined below.

==== Chained data-dependent subqueries

We propose the introduction of using the `WITH` projection clause as a new query combinator that can sequentially compose arbitrary queries to form a chained data-dependent subquery without having to resort to nesting and indentation (e.g. as a short-hand syntax for post-UNION processing).

Chained data-dependent subqueries have the following general form `<Q1> WITH ... <Q2>`.

Both `<Q1`> and `<Q2>` are arbitrary argument queries.

Conceptually, the query `<Q2>` is evaluated for each incoming input record from the query `<Q1>` and may produce an arbitrary number of result records.
In other words, the query `<Q2>` will be provided with all variables returned by the query `<Q1>` as input variable bindings.

Furthermore, this CIP proposes allowing a leading `WITH` to project new variables from expressions that refer to unbound variables from the preceding scope (or query).
This set of referenced, unbound variables of such a leading `WITH` is understood to implicitly declare the input variables required for the query to execute.

Note:: This mechanism allows composing a Cypher query with inputs that have been constructed programmatically.

==== Chained data-independent subqueries

We propose introducing the `THEN` projection clause as a new query combinator that can sequentially compose two arbitrary subqueries to form a chained data-independent subquery without having to resort to nesting and indentation.

Chained data-independent subqueries have the following general form `<Q1> THEN <Q2>`.

Both `<Q1`> and `<Q2>` are arbitrary argument queries.
No variables and no input records are passed from `<Q1>` to `<Q2>`.
Instead `<Q2>` is executed in a standalone fashion after the execution of `<Q1>` has finished.

Furthermore, this CIP proposes allowing queries to start with a leading `THEN` for discarding all variables in scope as well as the cardinality of all input records provided by the surrounding execution environment.

Note:: This mechanism allows guaranteed execution of an (usually updating) query `<Q2>` irrespective of the number of records produced by query `<Q1>`.

Note:: In general, `<Q1>` is expected to be an updating query and it is recommended that implementations generate a warning if this is not the case (to inform the user that `<Q1>` is essentially superfluous).

==== Query combinator precedence

This CIP proposes that all Cypher query combinators are left-associative regarding their left-hand side and right-hand side input queries.

Note:: In other words, `<Q1> UNION <Q2> WITH <Q3>` is always interpreted as  `(<Q1> UNION <Q2>) WITH <Q3>` but never as `<Q1> UNION (<Q2> WITH <Q3>)` (The same rule applies to `THEN`).

==== Discarding variables in scope

Finally, this CIP proposes new shorthand syntax for discarding all variables in scope without discarding the cardinality of input records using `WITH|RETURN|YIELD NOTHING`.

=== Examples

==== Read-only nested regular subqueries

Post-UNION processing:
[source, cypher]
----
MATCH {
  // authored tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:AUTHORED]-(tweet:Tweet)
  RETURN tweet, tweet.time AS time, user.country AS country
  UNION
  // favorited tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:HAS_FAVOURITE]-(favorite:Favorite)-[:TARGETS]->(tweet:Tweet)
  RETURN tweet, favourite.time AS time, user.country AS country
}
WHERE country = 'se'
RETURN DISTINCT tweet
ORDER BY time DESC
LIMIT 10
----

Uncorrelated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})-[:IS_IN]->(country:Country)
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Filtered and correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm)-[:IS_IN]->(country:Country)
WHERE country.name IN $countryNames
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b AS brand, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b AS brand, p.code AS code
}
WHERE f.type = 'organic'
  AND b.certified
RETURN f, brand.name AS name, code
----

Doubly-nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (c:Customer)-[:BUYS_FOOD_AT]->(f)
  MATCH {
     MATCH (c)-[:RETWEETS]->(t:Tweet)<-[:TWEETED_BY]-(f)
     RETURN c, count(*) AS count
     UNION
     MATCH (c)-[:LIKES]->(p:Posting)<-[:POSTED_BY]-(f)
     RETURN c, count(*) AS count
  }
  RETURN c, 'customer' AS type, sum(count) AS endorsement
  UNION
  MATCH (s:Shop)-[:BUYS_FOOD_AT]->(f)
  MATCH (s)-[:PLACES]->(a:Advertisement)-[:ABOUT]->(f)
  RETURN s, 'shop' AS type, count(a) * 100 AS endorsement
}
RETURN f.name AS name, type, sum(endorsement) AS endorsement
----

===== Read-only nested optional and mandatory subqueries

This proposal also provides nested subquery forms of `OPTIONAL MATCH` and `MANDATORY MATCH`:

[source, cypher]
----
MANDATORY MATCH (p:Person {name: 'Petra'})
MANDATORY MATCH (conf:Conference {name: $conf})
MANDATORY MATCH {
    WITH * WHERE conf.impact > 5
    MATCH (p)-[:ATTENDS]->(conf)
    RETURN conf
    UNION
    MATCH (p)-[:LIVES_IN]->(:City)<-[:IN]-(conf)
    RETURN conf
}
OPTIONAL MATCH {
    MATCH (p)-[:KNOWS]->(a:Attendee)-[:PUBLISHED_AT]->(conf)
    RETURN a.name AS name
    UNION
    MATCH (p)-[:KNOWS]->(a:Attendee)-[:PRESENTED_AT]->(conf)
    RETURN a.name AS name
}
RETURN name
----


==== Read/Write simple updating and conditionally-updating subqueries

We illustrate these by means of an 'old' version of the query, in which `FOREACH` is used, followed by the 'new' version, using `DO`.

Using a single subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH(x IN range(1, 10) |
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
)
----

Using a single subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO {
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
}
----

Note how `FOREACH` is addressing two semantic concerns simultaneously; namely looping, and performing updates without affecting the cardinality of the outer query.
In the new version of the query shown above, these orthogonal concerns have been separated.
Looping is already handled by `UNWIND`, while `DO` suppresses the increased cardinality from the inner query.

`DO` also hides all new variable bindings introduced by the inner query from the outer query.
If `DO` is omitted from the new version of the query shown above, the variable `c` would become visible to the remainder of the query.

Doubly-nested subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH (x IN range(1, 10) |
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  FOREACH (y IN range(1, 10) |
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  )
)
----

Doubly-nested subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x AS x
DO {
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  UNWIND range(1, 10) AS y
  DO {
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  }
}
----

Conditional `DO`
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO WHEN x % 2 = 1 THEN {
      MERGE (c:Odd:Child {id: x})
      MERGE (r)-[:PARENT]->(c)
  }
  ELSE {
      MERGE (c:Even:Child {id: x})
      MERGE (r)-[:PARENT]->(c)
  }
END
----

==== Chained subqueries

Combining nested and chained subqueries
[source, cypher]
----
MATCH (x)-[:IN]->(:Category {name: "A"})
WITH x LIMIT 5
MATCH (x)-[:FROM]-(c :City)
RETURN x, c
UNION
MATCH (x)-[:IN]->(:Category {name: "A"})
WITH x LIMIT 10
MATCH (x)-[:FROM]-(c :City)
// This finished the right arm of the UNION
RETURN x, c
// This applies to the whole UNION
WITH x.name AS name ORDER BY x.age
RETURN x LIMIT 10
----

=== Interaction with existing features

Apart from the suggested deprecation of the `FOREACH` clause, nested read-only, write-only and read-write subqueries do not interact directly with any existing features.

== Alternatives

Alternative syntax has been considered during the production of this document:

  * Using round braces; i.e. `MATCH (...)`
  * Using alternative keywords:

    ** `SUBQUERY`
    ** `QUERY`

== What others do

=== SQL

The following types of subqueries are supported in SQL:

Scalar:
[source, cypher]
----
SELECT orderID
FROM Orders
WHERE orderID =
  (SELECT max(orderID) FROM Orders)
----

Multi-valued:
[source, cypher]
----
SELECT customerID
FROM Customers
WHERE customerID IN
  (SELECT customerID FROM Orders)
----

Correlated:
[source, cypher]
----
SELECT orderID, customerID
FROM Orders AS O1
WHERE orderID =
  (SELECT max(O2.orderID) FROM Orders AS O2
   WHERE O2.customerID = O1.customerID)
----

Table-valued/table expression:
[source, cypher]
----
SELECT orderYear
FROM
  (SELECT YEAR(orderDate) AS orderYear
  FROM Orders) AS D
----

Scalar and list subqueries are addressed in the Scalar Subqueries and List Subqueries CIP.

=== SPARQL

https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#subqueries[SPARQL] supports uncorrelated subqueries in the standard, exemplified by:

[source, cypher]
----
SELECT ?y ?minName
WHERE {
  :alice :knows ?y .
 {
    SELECT ?y (MIN(?name) AS ?minName)
    WHERE {
      ?y :name ?name .
    } GROUP BY ?y
  }
}
----

Owing to the bottom-up nature of SPARQL query evaluation, the supported forms of subqueries are evaluated logically first, and the results are projected up to the outer query.
Variables projected out of the subquery will be visible, or in scope, to the outer query.


== Benefits to this proposal

* Increasing the expressivity of the language.
* Allowing unified post-processing on results from multiple (sub)queries; this is exemplified by the https://github.com/neo4j/neo4j/issues/2725[request for post-UNION processing].
* Facilitating query readability, construction and maintainability.
* Providing a feature familiar to users of SQL.

== Caveats to this proposal

At the current time, we are not aware of any caveats.
