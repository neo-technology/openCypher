= CIP2018-08-27 Type Filtering for Index-Backed Order-By (IBO)
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

:Date:      27.08.2018
:Revision:  0.1

*Authors:* Stefan Plantikow <stefan.plantikow@neo4j.com>,
Johan Teleman <johan.teleman@neo4j.com>,
Hannes Voigt <hannes.voigt@neo4j.com>

[abstract]
.Abstract
--
This CIP proposes to add functions that allow filtering the driving table by the data type category of an expression.
The type filtering is the explicit assurance to the query planner, that an order-by can be performed with the help of an index, since all the data type of the values that need to be order fall in the same category.
--

toc::[]

=== Background

Consider a Cypher queries such as the one shown in Example 1.

.Example 1
[source,cypher]
----
MATCH (n:Person)
RETURN n.yob
ORDER BY n.yob
----

Here, the property `n.yob` determines the order of the result set.
Sorting the result set by `n.yob` is an expensive and blocking operations.
If the user has created an link:https://neo4j.com/docs/developer-manual/3.4/cypher/schema/index/#schema-index-create-a-single-property-index[index] on `:Person(yob)` it is desirable to utilize the index, which stores `yob` values in order already, to produce a ordered result set.
This query execution feature is called _index-backed order-by_ (IBO).

As prerequisite for IBO is that all values `n.yob` have to have the same link:https://neo4j.com/docs/developer-manual/3.4/cypher/syntax/values/#property-types[property type].
As there is no link:https://neo4j.com/docs/developer-manual/3.4/cypher/schema/[schema information] ensuring a property to have a fix property type, the planner relies on the query to provide this assurance.
In Example 1, there is no possibility for the query planner to reason about the data type of `n.yob` values.
In consequence, the planner is not able to plan IBO for such a query.

A workaround for the user is to filter the result set for the a specific property of `n.yob`.
For instance, the user could rephrase the query to include `WHERE n.yob <= $min` with parameter `$min` set to `Integer.MIN_VALUE`, as shown in Example 2.

.Example 2
[source,cypher]
----
MATCH (n:Person)
WHERE n.yob <= $min
RETURN n.yob
ORDER BY n.yob
----

Although this lets the planner reason about the property type of `n.yob`, this solution is a very allusively way to express what is desired.
Neither is this workaround very intuitive nor obvious.

Type filter predicates are an explicit way of expressing the desired effect of selecting only `n.yob` values of a certain type.
Type filter predicates are useful beyond IBO, e.g. in data integration scenarios and generally when the user has to deal with mixed-typed values.
For instance, type filter predicates could be used in conditions of a `CASE` expression to cast and format mixed-typed values to a uniform appearance in the result set of a query.
Thus, an embedding of type filter predicates into the query language as first-class language constructs is generally desirable.

With the development of SQL/PG in progress and the development GQL at the horizon, type filter predicates as first-class language constructs have broader implication beyond Cypher and Neo4j.
Particularly, the GQL development will likely see some revision of the type system, naming of types, etc. whose results cannot be exactly foreseen, now.
Given the timelines of SQL/PG and GQL development, it is infeasible to master this implications and provide a future-proof design in a short timeframe.

Hence, this CIP proposes to extended Cypher with dedicated type-filtering predicates as second-class language constructs in form of functions.
This will allow to incorporate type-filtering predicates as first-class language constructs at a later point in time in a non-conflicting way.

=== Definition

==== Property Type Categories
Following the link:https://neo4j.com/docs/developer-manual/3.4/cypher/syntax/values/#property-types[property type categorization] of Cypher, we define a _property type category_ as being one of the categories listed in the following table.

|===
| *Category*      | *Types*
| Number          | Integer, Float
| String          | String
| Boolean         | Boolean
| Spatial         | Point
| Temporal        | Date, Time, LocalTime, DateTime, LocalDateTime, Duration
| ListOfNumbers   | List[Number]
| ListOfStrings   | List[String]
| ListOfBooleans  | List[Boolean]
| ListOfSpatials  | List[Point]
| ListOfTemporals | List[Date], List[Time], List[LocalTime], List[DateTime], List[LocalDateTime], List[Duration]
|===

For instance, property type category _Number_ includes all numeric type, precisely _Integer_ and _Float_.
Property type category _ListOfNumbers_ includes all property types that are a link:https://neo4j.com/docs/developer-manual/3.4/cypher/syntax/lists/[list] where all list elements have a property in the property type category _Number_.

==== Type Filter Predicate
A _type filter predicate_ (tfp) is an expression of the abstract form _tfp_(_exp_, _ptc_): _Option_[_Boolean_], where _exp_ is an arbitrary expression, _ptc_ is a property type category, and _Option_[_Boolean_] is a nullable _Boolean_, i.e. one of the three values {`true`,`false`,`NULL`}.

==== Type Filter Function
A _type filter function_ is a predicate function that provides the behavior of a type filter predicate.

=== Proposal

NOTE: We use ⟦_x_⟧ to denote the result of evaluating an expression _x_. For instance, ⟦`3+4`⟧ = `7`.

==== Semantics of Type Filter Predicates
A type filter predicate _tfp_(_exp_, _ptc_) returns, i.e. ⟦_tfp_(_exp_, _ptc_)⟧ equals
[horizontal]
`true`::
  if ⟦_exp_⟧ is not `NULL` and ⟦_exp_⟧ is of property type _t_ such that _t_ ∈ _ptc_
`false`::
  if ⟦_exp_⟧ is not `NULL` and ⟦_exp_⟧ is of property type _t_ such that _t_ ∉ _ptc_
`NULL`::
  if ⟦_exp_⟧ is `NULL`

==== Syntax of Type Filter Functions
We propose to introduce a dedicated type filter function for each of the property type categories.
Each type filter function is named starting with `is` followed by the of the property type category the function filters for.
Each type filter function takes an expression (`<exp>`) as its single parameter.
Precisely, we propose the following type filter function

|===
| *Category*      | *Type Filter Function*
| Number          | `isNumber(<exp>)`
| String          | `isString(<exp>)`
| Boolean         | `isBoolean(<exp>)`
| Spatial         | `isSpatial(<exp>)`
| Temporal        | `isTemporal(<exp>)`
| ListOfNumbers   | `isListOfNumbers(<exp>)`
| ListOfStrings   | `isListOfStrings(<exp>)`
| ListOfBooleans  | `isListOfBooleans(<exp>)`
| ListOfSpatials  | `isListOfSpatials(<exp>)`
| ListOfTemporals | `isListOfTemporals(<exp>)`
|===

==== Syntax of Type Filter Functions

We define the semantics of all type filter functions based on the general semantics of type filter predicates as defined in <<Semantics of Type Filter Predicates>>.
The semantics of the proposed type filter functions are as given in following table:

|===
| *Type Filter Function*     | *Semantics*
| `isNumber(`⁠_exp_⁠`)`          | ⟦`isNumber(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, Number)⟧
| `isString(`⁠_exp_⁠`)`          | ⟦`isString(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, String)⟧
| `isBoolean(`⁠_exp_⁠`)`         | ⟦`isBoolean(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, Boolean)⟧
| `isSpatial(`⁠_exp_⁠`)`         | ⟦`isSpatial(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, Spatial)⟧
| `isTemporal(`⁠_exp_⁠`)`        | ⟦`isTemporal(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, Temporal)⟧
| `isListOfNumbers(`⁠_exp_⁠`)`   | ⟦`isListOfNumbers(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, ListOfNumbers)⟧
| `isListOfStrings(`⁠_exp_⁠`)`   | ⟦`isListOfStrings(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, ListOfStrings)⟧
| `isListOfBooleans(`⁠_exp_⁠`)`  | ⟦`isListOfBooleans(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, ListOfBooleans)⟧
| `isListOfSpatials(`⁠_exp_⁠`)`  | ⟦`isListOfSpatials(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, ListOfSpatials)⟧
| `isListOfTemporals(`⁠_exp_⁠`)` | ⟦`isListOfTemporals(`⁠_exp_⁠`)`⟧ = ⟦_tfp_(_exp_, ListOfTemporals)⟧
|===

==== Example

Assuming `yob` in Example 2 is (usually) a number, Example 2 could be expressed with the proposed type filter functions as shown in Example 3.

.Example 3
[source,cypher]
----
MATCH (n:Person)
WHERE isNumber(n.yob)
RETURN n.yob
ORDER BY n.yob
----

This will ensure that for every result tuple `n.yob` is a number and an index on `n.yob` can be used to determine the order.
