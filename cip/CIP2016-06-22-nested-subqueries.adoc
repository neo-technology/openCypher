= CIP2016-06-22 - Nested subqueries
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Petra Selmer <petra.selmer@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP proposes the incorporation of nested subqueries into Cypher.
--

toc::[]


== Motivation

Subqueries - i.e. queries within queries - are a powerful and expressive feature allowing for:

  * Increased query expressivity
  * Better query construction and readability
  * Easier query composition and reuse
  * Post-processing as a single unit results from multiple queries
  * Perform a sequence of multiple write commands for each record

== Background

This CIP may be viewed in light of the EXISTS CIP and the forthcoming Pattern Comprehension CIP, both of which propose variants of subqueries.

== Proposal

Nested subqueries are self-contained Cypher queries that are run within the scope of an outer Cypher query.

This proposal suggests the introduction of new nested subquery constructs to Cypher.

* Read-only nested match subqueries of the form `MATCH { [(a)->(b) [WHERE ...]] ... RETURN * }`
* Read-only nested optional match subqueries of the form `OPTIONAL { [(a)->(b) [WHERE ...]] ... RETURN * }`
* Read-only nested mandatory match subqueries of the form `MANDATORY { [(a)->(b) [WHERE ...]] ... [RETURN *] }`
* Read/Write nested subqueries of the form `DO WHEN ... { ... }` (not ending with `RETURN`)

All forms are introduced with a keyword in conjunction with optional subclauses which are then followed by an inner query in curly braces.

Nested subqueries may be correlated - i.e. the inner query may use variables from the outer query - or uncorrelated.

Nested subqueries can be contained within other nested subqueries at an arbitrary (but finite) depth.


**1. Read-only nested match subqueries**

We propose the addition of new syntax to the `MATCH` clause for expressing read-only nested match subqueries.

A nested read-only match subquery is denoted using the following syntax: `MATCH { <inner-match-query> }`.

The inner match query is a full read-only Cypher query.

Moreover, any valid read-only Cypher query from which the leading `MATCH` keyword has been omitted may also be used as an inner match query.

This rule only applies if the leading `MATCH` clause is the root clause of the inner query (i.e. is not the first clause inside a nested query or a `UNION`).


**2. Read-only nested optional match subqueries**

We propose the addition of a new `OPTIONAL` clause for expressing read-only nested optional match subqueries.

A nested read-only optional match subquery is denoted using the following syntax: `OPTIONAL { <inner-match-query> }`.


**3. Read-only nested mandatory match subqueries**

We propose the addition of a new `MANDATORY` clause for expressing read-only nested mandatory match subqueries.

A nested read-only mandatory match subquery is denoted using the following syntax: `MANDATORY { <inner-mandatory-query> }`.

The inner mandatory query is any inner match query.

Moreover, any inner match query from which the trailing final `RETURN` clause has been omitted may also be used as an inner mandatory query.


**4. Read/Write nested subqueries**

We propose the addition of a new `DO` clause for expressing read/write nested subqueries that _do no return any data_.

A nested read/write subquery is denoted using the following syntax: `DO [WHEN predicate] { <inner-update-query> }`.

Any updating Cypher query from which the trailing final `RETURN` clause has been omitted may be used as an inner update query.

Using a
We additionally propose removing the `FOREACH` clause from the current language as it is rendered obsolete by the introduction of `DO`.


=== Semantic clarification

**1. Read-only nested subqueries**

Conceptually, a nested subquery is evaluated for each incoming record and may produce an arbitrary number of result records.

All incoming variables remain in scope.
Any new variable bindings introduced by the final `RETURN` clause when evaluating the subquery will augment the variable bindings of the initial record.
Therefore, nested subqueries cannot shadow variables present in the outer scope, and thus behave in the same way as `UNWIND` and `CALL` with regard to the introduction of new variable bindings.
Any other variable bindings that are introduced temporarily in the subquery will not be visible to the outer scope.

Subqueries interact with write clauses in the same way as `MATCH` does.


**2. Read/Write subqueries**

Execution of a `DO` subquery does not change the cardinality; i.e. the inner update query is run for each incoming record (optionally filtered by the given predicate if a `WHEN` sub-clause is present).

Any input record is always passed on to the clause succeeding the `DO` subquery, irrespective of whether it was eligible for processing by the inner update query.

A `DO` clause that uses `WHEN` sub-clause is called _conditional DO_.

A query may end with a `DO` subquery in the same way that a query can currently end with any update clause.

=== Examples

**1. Read-only nested match subqueries**

Post-UNION processing:
[source, cypher]
----
MATCH {
  // authored tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:AUTHORED]-(tweet:Tweet)
  RETURN tweet, tweet.time AS time, user.country AS country
  UNION
  // favorited tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:HAS_FAVOURITE]-(favorite:Favorite)-[:TARGETS]->(tweet:Tweet)
  RETURN tweet, favourite.time AS time, user.country AS country
}
WHERE country = 'se'
RETURN DISTINCT tweet
ORDER BY time DESC
LIMIT 10
----

Uncorrelated nested match subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Correlated nested match subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})-[:IS_IN]->(country:Country)
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Filtered and correlated nested match subquery:
[source, cypher]
----
MATCH (f:Farm)-[:IS_IN]->(country:Country)
WHERE country.name IN $countryNames
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b AS brand, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b AS brand, p.code AS code
}
WHERE f.type = 'organic'
  AND b.certified
RETURN f, brand.name AS name, code
----

Doubly-nested match subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  (c:Customer)-[:BUYS_FOOD_AT]->(f)
  MATCH {
     MATCH (c)-[:RETWEETS]->(t:Tweet)<-[:TWEETED_BY]-(f)
     RETURN c, count(*) AS count
     UNION
     MATCH (c)-[:LIKES]->(p:Posting)<-[:POSTED_BY]-(f)
     RETURN c, count(*) AS count
  }
  RETURN c, 'customer' AS type, sum(count) AS endorsement
  UNION
  MATCH (s:Shop)-[:BUYS_FOOD_AT]->(f)
  MATCH (s)-[:PLACES]->(a:Advertisement)-[:ABOUT]->(f)
  RETURN s, 'shop' AS type, count(a) * 100 AS endorsement
}
RETURN f.name AS name, type, sum(endorsement) AS endorsement
----

**2. Read/Write nested subqueries**

We illustrate these by means of an 'old' version of the query, in which `FOREACH` is used, followed by the 'new' version, using `DO`.

Using a single subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH(x IN range(1, 10) |
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
)
----

Using a single subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO {
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
}
----

Note how `FOREACH` is addressing two semantic concerns simultaneously; namely looping, and performing updates without affecting the cardinality of the outer query.
In the new version of the query shown above, these orthogonal concerns have been separated.
Looping is already handled by `UNWIND`, while `DO` suppresses the increased cardinality from the inner query.

`DO` also hides all new variable bindings introduced by the inner query from the outer query.
If `DO` is omitted from the new version of the query shown above, the variable `c` would become visible to the remainder of the query.

Doubly-nested subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH (x IN range(1, 10) |
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  FOREACH (y IN range(1, 10) |
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  )
)
----

Doubly-nested subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x AS x
DO {
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  UNWIND range(1, 10) AS y
  DO {
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  }
}
----

Conditional `DO`
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO WHEN x % 2 = 1 {
  MERGE (c:Odd:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
}
----


=== Interaction with existing features

Apart from the suggested deprecation of the `FOREACH` clause, nested read-only, write-only and read-write subqueries do not interact directly with any existing features.

=== Alternatives

Alternative syntax has been considered during the production of this document:

  * Using round braces; i.e. `MATCH (...)`
  * Using alternative keywords:

    ** `SUBQUERY`
    ** `QUERY`

== What others do

=== SQL

The following types of subqueries are supported in SQL:

Scalar:
[source, cypher]
----
SELECT orderID
FROM Orders
WHERE orderID =
  (SELECT max(orderID) FROM Orders)
----

Multi-valued:
[source, cypher]
----
SELECT customerID
FROM Customers
WHERE customerID IN
  (SELECT customerID FROM Orders)
----

Correlated:
[source, cypher]
----
SELECT orderID, customerID
FROM Orders AS O1
WHERE orderID =
  (SELECT max(O2.orderID) FROM Orders AS O2
   WHERE O2.customerID = O1.customerID)
----

Table-valued/table expression:
[source, cypher]
----
SELECT orderYear
FROM
  (SELECT YEAR(orderDate) AS orderYear
  FROM Orders) AS D
----

Both scalar and table expression subqueries are out of scope for the purposes of this CIP. They will be addressed in forthcoming CIPs.

=== SPARQL

https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#subqueries[SPARQL] supports uncorrelated subqueries in the standard, exemplified by:

[source, cypher]
----
SELECT ?y ?minName
WHERE {
  :alice :knows ?y .
 {
    SELECT ?y (MIN(?name) AS ?minName)
    WHERE {
      ?y :name ?name .
    } GROUP BY ?y
  }
}
----

Owing to the bottom-up nature of SPARQL query evaluation, the supported forms of subqueries are evaluated logically first, and the results are projected up to the outer query.
Variables projected out of the subquery will be visible, or in scope, to the outer query.


== Benefits to this proposal

* Increasing the expressivity of the language.
* Allowing unified post-processing on results from multiple (sub)queries; this is exemplified by the https://github.com/neo4j/neo4j/issues/2725[request for post-UNION processing].
* Facilitating query readability, construction and maintainability.
* Providing a feature familiar to users of SQL.

== Caveats to this proposal

At the current time, we are not aware of any caveats.
