CIP2015-06-24 Managing Stored Procedures
========================================
:Title: CIP2015-02-17-managing-stored-procedures
:Status: Drafted
:Author: Rickard Ã–berg and Stefan Plantikow and Nigel Small and Petra Selmer
:Email: rickard.oberg@neotechnology.com and stefan.plantikow@neotechnology.com and nigel.small@neotechnology.com and petra.selmer@neotechnology.com
:source-highlighter: pygments
:numbered:
:toc: manual
:toc-placement: macro

== Abstract

This proposal introduces stored procedures as a new concept to Cypher and proposes the addition of various facilities
for calling and managing them.

User-defined functions are a separate concern that might be addressed in a future CIP.

toc::[]

== Motivation & Background

While Cypher is a very expressive graph query language, its declarative nature and scope is currently not sufficient for
expressing certain classes of graph traversals (e.g. traversals relying on using specialized data structures, like
certain queues) or accessing third-party functionality.

This CIP proposes to add stored procedures to Cypher in order to address these issues.

Furthermore, to make the new binary protocol _bolt_ the primary and in the long term the exclusive surface to Neo4j, all
current user-accessible functionality needs to be made available via it. As part of this effort, stored procedures will
be used to replace all existing public extension mechanisms (Server Plugins and Unmanaged Extensions).

This CIP uses the type annotation syntax that was introduced recently.

== Proposal

This proposal consists of three parts, introducing stored procedures conceptually, describing how to call them in a
system that supports Cypher, and detailing language additions for their management.

=== Stored procedures

A stored procedure has a name and takes a fixed number of named and typed arguments in a fixed sequence and either just
yields nothing (i.e. causes a side effect) or yields a stream of records.  Each record yielded contains values for a
fixed number of named and typed columns in the same fixed sequence such that each column value in a yielded record
matches its column's type.

The name of the stored procedure, its argument names, and if applicable any result column names must not contain any
leading or trailing whitespace characters and must not be empty.

The arguments of the procedure, their types, and their order are called its argument signature. All information about
what is being returned by the procedure (either if the procedure yields nothing or the result columns, their types, and
their order) are called the result signature of the procedure. Together, the argument signature and the result signature
form the (full) signature of the stored procedure.

A procedure may take zero arguments and/or may yield zero columns.

Procedures may be written in different programming languages and provided with APIs for accessing the underlying graph
database or graph processing system as dictated by the implementation.

=== Calling stored procedures

A procedure call constitutes an entire Cypher statement. According to this CIP, a procedure cannot be used alongside
other clauses. It is intended that this restriction will be lifted in the future.

Calling a stored procedures requires providing it with argument values. This may be done in one of two ways.

==== Call with arguments

Arguments are provided as a sequence of expressions as required by the procedure's signature. To call the procedure, all
argument expressions are evaluated to argument values in order. It is an error, if the number of provided arguments
differs from the number of arguments required by the procedure's argument signature. It is an error, if the argument
values are incompatible with the argument types required by the procedure's argument signature.

[source, cypher]
----
CALL myProc("Test", 1+2)
----

==== Call with parameters

Arguments are provided as parameters to the Cypher query. To call the procedure, the argument values are obtained by
using the parameter in scope with the same name as the argument. If such a parameter does not exist, the argument value
is assumed to be `NULL`. It is an error, if the resulting argument values are incompatible with the argument types
required by the procedure's argument signature.

[source, cypher]
----
CALL myProc
----

=== Executing the call

The details of how procedures are executed are left to the implementation. The statement may not yield if a procedure
fails to yield. It is an error if a procedure fails to yield arguments in accordance with its declared result signature.

If a procedure yields nothing, the Cypher statement yields no rows and the list of return columns is empty.

If a procedure yields records, these records are yielded from the Cypher statement in the same order as they are
yielded by the procedure and the list of return columns of the statement is set to be the sequence of result columns
of the procedure's result signature.

If a procedure call fails to execute ("throws an exception"), this error is propagated to the user in the same way
as other runtime errors are propagated to the user by the implementation. The error message should provide the
user at least with the name of the failed stored procedures, its signature, and all argument values.

=== Managing procedures

The management of procedures comprises the following:

* Creating or replacing procedures
* Dropping procedures

==== Creating or replacing procedures

Creating a procedure is the process of registering code written in a supported extension language (like Java)
under a user-specified name such that it may be executed later as a Cypher statement.

There are two variants of this functionality depending on whether a procedure with the same name already has been
registered: `CREATE PROCEDURE` expects the procedure name to not have been registered previously and fails with an error
if that is not the case. `CREATE OR REPLACE PROCEDURE` will register the procedure in any case.

It is not possible to register two procedures with the same name but different signatures, i.e. overloading is
not supported.

Registering a procedure may fail for implementation specific reasons that include lack of support for the
extension language or the presence of built-in procedures that may not be overridden. It is suggested that
the names of built-in procedures start with the prefix `"_"`.

Creating a procedures requires specifying its name, its signature, the used extension language, and the code to be
executed.

The extension language is specified as a non-empty string literal. It is preferred that extension language names should
be lowercase by default and separate multiple words using a single space. They should neither start nor end with
whitespace characters. An implementation may choose to provide multiple names for the same extension language.

The code to be executed may be specified either by providing it as a string or by providing an URL from which it may be
loaded. If code is specified as an URL, it must be loaded and registered immediately as part of executing `CREATE
PROCEDURE`. In other words, `LOAD FROM` blocks until all code has been loaded.

This CIP considers security features for ensuring secure loading of code (i.e. by limiting supported URL schemes) out of
scope and delegates addressing this to implementations.

Furthermore, storage of code is also considered to be an implementation concern except that the implementation must
guarantee to call the code provided at procedure creation time exactly as given.

==== Dropping stored procedures

Dropping a stored procedure is the process of removing all information about a previously registered stored procedure.

To drop a stored procedure, its name must be provided. Giving the signature is not needed (and not allowed) for dropping
a stored procedure since overloading is not supported under this proposal.

It is an error to drop an unknown or already (previously) dropped stored procedures.

After dropping a stored procedure its name may be used again for creating a new stored procedure using the same or
different code.

Dropping a stored procedure may fail for implementation specific reasons (i.e. the procedure is a built-in procedure
that may not be deleted).

=== Syntax

[source, ebnf]
----
statement          = "CREATE", "PROCEDURE", procedure name, signature, from
                   | "CREATE", "OR", "REPLACE", "PROCEDURE", procedure name, signature, from
                   | "DROP", "PROCEDURE", procedure name
                   | procedure call
                   | ...
                   ;

procedure call     = "CALL", procedure name, "(", [ expression,  { ",", expression } ], ")"
                   | "CALL", procedure name
                   ;

procedure name     = regular identifier ;

signature          = argument signature, "::", result signature

argument signature = "(", arguments, ")"

arguments          = [ argument, { ",", argument } ];

argument           = regular identifier, type annotation ;

result signature   = ""(", result columns, ")"
                   | "VOID"
                   ;

result columns     = [ result column, { ",", result column } ];

result column      = regular identifier, type annotation ;

from   	           = language, source ;

language           = "LANGUAGE", string literal ;

source             = "LOAD", "FROM", location
                   | "FROM", string literal
                   ;

(* an url *)
location           = string literal ;

(* non-empty and without any leading or trailing whitespace *)
regular identifier = identifier ;
----

==== Example

Below we create a procedure called `getCityInfo` with the following defining features:

* The name `getCityInfo`
* Two positional input arguments:
** a `city` of type `STRING`
** a `nodeId` of type `IDENTITY`
* Each record yielded will contain two columns
** the number of `inhabitants` as `INTEGER`
** a `country` of type `STRING`
* The code for the procedure is loaded from:
** written in `"Javascript"`
** a resource identified by the URI `"file:///tmp/foo.js#CityDetails"`

[source,cypher]
----
CREATE PROCEDURE getCityInfo(city :: STRING, nodeId :: IDENTITY)
                         :: (inhabitants :: INTEGER, country :: STRING)
LANGUAGE "javascript"
LOAD FROM "file:///tmp/foo.js#CityDetails"
----

Next we drop the procedure `getCityInfo` again

[source,cypher]
----
DROP PROCEDURE getCityInfo
----

== What others do

The stored procedures survey (separate google doc) is extremely comprehensive, examining how stored procedures are
implemented and deployed as well as their API access mechanisms and usage. Products surveyed include PostgreSQL, MS SQL
Server, Oracle, MySQL, MongoDB, Aerospike and Virtuoso.

== Benefits to this proposal

The benefits of having user-defined extensions is so that users would be able to implement algorithms and functionality
which Cypher cannot either express or which cannot be executed efficiently by current implementations. Additionally,
users may find extensions to be a useful mechanism to achieve good system design and code abstraction.

== Audience Consultation

To be defined

== Caveats to this proposal

All of the following shall be dealt with as part of future work, or as part of an upcoming design sprint:

* User-defined functions
* The extension API
* The mechanism by which results are delivered
* Error handling

== Appendix

All content in this appendix is informative only. It serves to capture the discussion around this CIP.

=== Listing procedures

The listing of procedures could be done in various ways, for example via dedicated syntax, a system graph, or a built-in
procedure.  Any mechanism for listing should also extend to other schema artifacts, like indices or constraints and
was thus considered out of scope for this CIP. Furthermore, it may be necessary to be able to filter the stored
procedures listed when there are many.

Suggested syntax for this feature was: `SHOW PROCEDURES` possibly followed by `STARTS WITH`, `CONTAINS`, or
`ENDS WITH`.

[source,cypher]
----
SHOW PROCEDURES
SHOW PROCEDURES WHERE name STARTS WITH "app."
SHOW PROCEDURES WHERE name ENDS WITH "Info"
----

Listing should return

* the name of the procedure
* the signature as a string
* the language in which the procedure was written
* possibly if the procedure is built-in or was user-defined

=== Supporting Procedures with more complex Signatures

We could consider allowing a procedure to be able to accept any of the following:

* Optional and default arguments
* A variable number of arguments (similar to Java's variadic arguments)
* Multiple argument groups

Furthermore we could consider supporting calling procedures with explicitly named arguments (similar to Python's
kwargs).

These features should be introduced in a future CIP, if required.
